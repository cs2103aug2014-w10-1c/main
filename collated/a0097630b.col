//@author: a0097630b



	/**
	 * origin: .\You-Controller\controller.cpp
	 */

#include "stdafx.h"
#include "You-NLP/query_parser.h"
#include "You-NLP/parse_tree.h"
#include "internal/query_executor.h"
#include "internal/query_executor_builder_visitor.h"
#include "result.h"
#include "controller_context.h"
#include "controller.h"

namespace You {
namespace Controller {

using You::NLP::QueryParser;
using QueryParseTree = You::NLP::QUERY;
using AbstractQuery = QueryEngine::Query;

Controller Controller::instance;
const std::unordered_map<NLP::TaskPriority, Task::Priority>
Controller::nlpToQueryEnginePriorityMap({
	{ NLP::TaskPriority::NORMAL, Task::Priority::NORMAL },
	{ NLP::TaskPriority::HIGH, Task::Priority::HIGH }
});
const std::unordered_map<Task::Priority, NLP::TaskPriority>
Controller::queryEngineToNlpPriorityMap({
	{ Task::Priority::NORMAL, NLP::TaskPriority::NORMAL },
	{ Task::Priority::HIGH, NLP::TaskPriority::HIGH }
});

Controller& Controller::get() {
	return instance;
}

Result Controller::query(
	const std::wstring& query,
	const Controller::Context& context) const {
	QueryParseTree parseTree = QueryParser::parse(query);

	Internal::QueryExecutorBuilderVisitor visitor(context);
	std::unique_ptr<Internal::QueryExecutor> executor(
		boost::apply_visitor(visitor, parseTree));

	return executor->execute();
}

TaskList Controller::getTasks(const std::vector<Task::ID>& taskIDs) const {
	std::unique_ptr<AbstractQuery> query =
		QueryEngine::GetTask(QueryEngine::Filter::idIsIn(taskIDs));

	return boost::get<TaskList>(QueryEngine::executeQuery(std::move(query)));
}

TaskList Controller::getTasks() const {
	std::unique_ptr<AbstractQuery> query =
		QueryEngine::GetTask();

	return boost::get<TaskList>(QueryEngine::executeQuery(std::move(query)));
}

Task::Priority Controller::nlpToQueryEnginePriority(
	NLP::TaskPriority priority) {
	 auto iterator = nlpToQueryEnginePriorityMap.find(priority);
	 assert(iterator != end(nlpToQueryEnginePriorityMap));
	 return iterator->second;
}

NLP::TaskPriority Controller::queryEngineToNlpPriority(
	QueryEngine::Task::Priority priority) {
	auto iterator = queryEngineToNlpPriorityMap.find(priority);
	assert(iterator != end(queryEngineToNlpPriorityMap));
	return iterator->second;
}

}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller\controller.cpp





	/**
	 * origin: .\You-Controller\controller.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_CONTROLLER_H_
#define YOU_CONTROLLER_CONTROLLER_H_

#include <string>
#include <unordered_map>
#include "result.h"

namespace You {
namespace NLP { enum class TaskPriority; }
namespace Controller {
namespace Internal {
class QueryExecutorBuilderVisitor;

namespace UnitTests { class QueryExecutorBuilderVisitorTests; }
}  // namespace Internal
namespace UnitTests { class ControllerContextTests; }

/// The entry-point for all communications with the rest of the You
/// framework.
///
/// This is a singleton class.
class Controller {
	friend class UnitTests::ControllerContextTests;
	friend class Internal::QueryExecutorBuilderVisitor;
	friend class Internal::UnitTests::QueryExecutorBuilderVisitorTests;

public:
	class Context;

public:
	/// Gets the singleton instance for the controller.
	static Controller& get();

	/// Executes the given natural language query.
	///
	/// \param[in] query The natural language query to execute.
	/// \param[in] context The task list context in which the query is run.
	/// \return The result of the query.
	/// \exception ContextRequiredException This is raised when a context is
	///                                     needed for the query to run.
	/// \see Result The result is polymorphic.
	Result query(const std::wstring& query, const Context& context) const;

	/// Gets all tasks with their IDs in the given list.
	///
	/// \remarks Order is preserved when returned.
	/// \param[in] taskIDs The task IDs to return.
	/// \return The tasks with the given ID.
	TaskList getTasks(const std::vector<Task::ID>& taskIDs) const;

	/// Gets all tasks.
	///
	/// \return The tasks currently in the data store.
	TaskList getTasks() const;

private:
	Controller(const Controller&) = delete;
	Controller& operator=(const Controller&) = delete;
	Controller() = default;


private:
	/// Converts an NLP Task Priority to the equivalent Query Engine task
	/// priority.
	static Task::Priority nlpToQueryEnginePriority(NLP::TaskPriority priority);

	/// Converts an Query Engine Task Priority to the equivalent NLP Task
	/// Priority.
	static NLP::TaskPriority queryEngineToNlpPriority(
		QueryEngine::Task::Priority priority);

private:
	/// The global singleton instance of the controller.
	static Controller instance;

	/// The map for converting NLP Task priorities to actual Query Engine
	/// task priorities.
	static const std::unordered_map<NLP::TaskPriority, Task::Priority>
		nlpToQueryEnginePriorityMap;

	/// The map for converting Query Engine task priorities to NLP Task
	/// priorities.
	static const std::unordered_map<Task::Priority, NLP::TaskPriority>
		queryEngineToNlpPriorityMap;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_CONTROLLER_H_

	// End of segment: .\You-Controller\controller.h





	/**
	 * origin: .\You-Controller\controller_context.cpp
	 */

#include "stdafx.h"
#include "controller_context.h"
#include "exceptions/context_required_exception.h"

namespace You {
namespace Controller {

const Controller::Context Controller::Context::DEFAULT =
	Controller::Context();

Controller::Context::Context(const TaskList& taskList)
: context(taskList) {
}

Controller::Context::Context()
: context(const_cast<void*>(static_cast<void const*>(&DEFAULT))) {
}

bool Controller::Context::isDefault() const {
	void* const* result = boost::get<void*>(&context);
	return result != nullptr && *result == &DEFAULT;
}

const Task& Controller::Context::at(size_t offset) const {
	if (isDefault()) {
		throw ContextRequiredException();
	}

	return boost::get<TaskList>(context).at(offset);
}

const Task& Controller::Context::operator[](size_t offset) const {
	if (isDefault()) {
		throw ContextRequiredException();
	}

	return boost::get<TaskList>(context)[offset];
}

}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller\controller_context.cpp





	/**
	 * origin: .\You-Controller\controller_context.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_CONTROLLER_CONTEXT_H_
#define YOU_CONTROLLER_CONTROLLER_CONTEXT_H_

#include "controller.h"

namespace You {
namespace Controller {
namespace UnitTests { class ControllerContextTests; }

/// Represents a context of a query. This is usually a task list so that
/// relative indices can be used in a query.
class Controller::Context {
	friend class UnitTests::ControllerContextTests;

	/// The set of possible types that can form a context.
	typedef boost::variant<void*, TaskList> Types;

public:
	/// Task List conversion constructor.
	Context(const TaskList& taskList);  // NOLINT(runtime/explicit)

	/// Get the task at the given offset.
	///
	/// \param[in] offset The offset to retrieve.
	/// \exception ContextRequiredException When the given context is the
	///                                     default context.
	/// \exception std::out_of_range When the offset is larger than the number
	///                              of tasks present.
	const Task& at(size_t offset) const;

	/// Get the task at the given offset.
	///
	/// \param[in] offset The offset to retrieve.
	/// \exception ContextRequiredException When the given context is the
	///                                     default context.
	const Task& operator[](size_t offset) const;

public:
	/// This is the global default context.
	static const Context DEFAULT;

private:
	/// Hidden default constructor. Use \ref Context::DEFAULT for the
	/// default context.
	///
	/// \see Context::DEFAULT
	Context();

	/// Checks if the given context is the default context.
	///
	/// \return true if the current context is the default context.
	bool isDefault() const;

private:
	/// The actual context.
	Types context;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_CONTROLLER_CONTEXT_H_

	// End of segment: .\You-Controller\controller_context.h





	/**
	 * origin: .\You-Controller\exception.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_EXCEPTION_H_
#define YOU_CONTROLLER_EXCEPTION_H_

#include "exceptions/exception.h"
#include "exceptions/context_required_exception.h"
#include "exceptions/context_index_out_of_range_exception.h"
#include "You-NLP/exception.h"
#include "You-QueryEngine/exception.h"
#include "You-DataStore/exception.h"

namespace You {
namespace Controller {

typedef You::Utils::Exception Exception;

typedef You::QueryEngine::Exception::EmptyTaskDescriptionException
	EmptyTaskDescriptionException;

typedef You::QueryEngine::Exception::TaskNotFoundException
	TaskNotFoundException;

typedef You::QueryEngine::Exception::CircularDependencyException
	CircularDependencyException;

typedef You::QueryEngine::Exception::NotUndoAbleException
	NotUndoAbleException;

typedef You::NLP::ParserException ParserException;

typedef You::NLP::ParserTypeException ParserTypeException;

typedef You::NLP::ParseErrorException ParseErrorException;

typedef You::DataStore::IOException IOException;

typedef You::DataStore::NotWellFormedXmlException NotWellFormedXmlException;

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_EXCEPTION_H_

	// End of segment: .\You-Controller\exception.h





	/**
	 * origin: .\You-Controller\exceptions\context_index_out_of_range_exception.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_EXCEPTIONS_CONTEXT_INDEX_OUT_OF_RANGE_EXCEPTION_H_
#define YOU_CONTROLLER_EXCEPTIONS_CONTEXT_INDEX_OUT_OF_RANGE_EXCEPTION_H_

#include "exception.h"

namespace You {
namespace Controller {

/// A context index out of range exception. This can be caught using the You
/// exception base class or std::out_of_range.
class ContextIndexOutOfRangeException :
	public virtual Exception,
	public virtual std::out_of_range {
public:
	/// Creates a new exception.
	inline ContextIndexOutOfRangeException()
	: std::out_of_range(nullptr) {
	}

	/// Constructs the exception from an existing std::out_of_range
	///
	/// \param[in] exception The exception to construct the new exception from.
	inline explicit ContextIndexOutOfRangeException(
		const std::out_of_range& exception)
	: std::out_of_range(exception) {
	}

	/// Copy constructor.
	inline ContextIndexOutOfRangeException(
		const ContextIndexOutOfRangeException &exception)
	: Exception(exception), std::out_of_range(exception) {
	}
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_EXCEPTIONS_CONTEXT_INDEX_OUT_OF_RANGE_EXCEPTION_H_

	// End of segment: .\You-Controller\exceptions\context_index_out_of_range_exception.h





	/**
	 * origin: .\You-Controller\exceptions\context_required_exception.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_EXCEPTIONS_CONTEXT_REQUIRED_EXCEPTION_H_
#define YOU_CONTROLLER_EXCEPTIONS_CONTEXT_REQUIRED_EXCEPTION_H_

#include "exception.h"

namespace You {
namespace Controller {

class ContextRequiredException : public Exception {
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_EXCEPTIONS_CONTEXT_REQUIRED_EXCEPTION_H_

	// End of segment: .\You-Controller\exceptions\context_required_exception.h





	/**
	 * origin: .\You-Controller\exceptions\exception.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_EXCEPTIONS_EXCEPTION_H_
#define YOU_CONTROLLER_EXCEPTIONS_EXCEPTION_H_

#include "You-Utils/exceptions/exception.h"

namespace You {
namespace Controller {

typedef You::Utils::Exception Exception;

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_EXCEPTIONS_EXCEPTION_H_

	// End of segment: .\You-Controller\exceptions\exception.h





	/**
	 * origin: .\You-Controller\internal\query_executor.cpp
	 */

#include "stdafx.h"
#include "query_executor.h"

namespace You {
namespace Controller {
namespace Internal {

QueryExecutor::QueryExecutor(std::unique_ptr<You::QueryEngine::Query>&& query)
: query(std::move(query)) {
}

Result QueryExecutor::execute() {
	assert(query.get() &&
		"QueryExecutors are single-use only.");
	QueryEngine::Response response = QueryEngine::executeQuery(
		std::move(query));
	return processResponse(response);
}

}  // namespace Internal
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller\internal\query_executor.cpp





	/**
	 * origin: .\You-Controller\internal\query_executor.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_H_
#define YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_H_

#include <memory>

#include "You-QueryEngine/api.h"
#include "../result.h"

namespace You {
namespace Controller {
namespace Internal {
namespace UnitTests { class QueryExecutorTests; }

/// Forms an abstract base class for all query executors.
///
/// Query Executors accept a query object, returned from the Query Builder.
/// The Query Executor has an associated method to parse the response from the
/// Query Builder, returning the appropriate result to the consumers of the
/// controller.
class QueryExecutor {
	friend class UnitTests::QueryExecutorTests;

public:
	/// Default virtual constructor.
	virtual ~QueryExecutor() = default;

	/// Executes the query, returning the concrete result.
	///
	/// \return The concrete result of the query.
	Result execute();

protected:
	/// Constructor.
	///
	/// \param[in] query The query which was retrieved from the Query Engine.
	explicit QueryExecutor(std::unique_ptr<You::QueryEngine::Query>&& query);

	/// Processes the response from the query engine, returning a result.
	///
	/// \param[in] response The response from the Query Engine.
	/// \return The concrete result corresponding to the query.
	virtual Result processResponse(
		const You::QueryEngine::Response& response) = 0;

private:
	/// The query object which we are encapsulating.
	std::unique_ptr<You::QueryEngine::Query> query;
};

}  // namespace Internal
}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_H_

	// End of segment: .\You-Controller\internal\query_executor.h





	/**
	 * origin: .\You-Controller\internal\query_executor_builder_visitor.cpp
	 */

#include "stdafx.h"
#include "You-Utils/fatal.h"
#include "You-Utils/algorithms.h"

#include "query_executor.h"
#include "../exceptions/context_index_out_of_range_exception.h"
#include "../result.h"
#include "query_executor_builder_visitor.h"

namespace You {
namespace Controller {
namespace Internal {

using You::NLP::TaskField;
using You::NLP::TaskPriority;
using You::NLP::QUERY;
using You::NLP::ADD_QUERY;
using You::NLP::SHOW_QUERY;
using You::NLP::EDIT_QUERY;
using You::NLP::DELETE_QUERY;
using You::NLP::UNDO_QUERY;

QueryExecutorBuilderVisitor::QueryExecutorBuilderVisitor(
	const Controller::Context& context)
	: context(context) {
}

std::unique_ptr<QueryExecutor>
QueryExecutorBuilderVisitor::build(const ADD_QUERY& query) {
	class AddTaskQueryExecutor : public QueryExecutor {
	public:
		explicit AddTaskQueryExecutor(
			std::unique_ptr<QueryEngine::Query>&& query)
			: QueryExecutor(std::move(query)) {
		}

		virtual ~AddTaskQueryExecutor() = default;

	protected:
		Result processResponse(
			const You::QueryEngine::Response& response) override {
			return ADD_RESULT {
				boost::get<Task>(response)
			};
		}
	};

	return std::unique_ptr<QueryExecutor>(
		new AddTaskQueryExecutor(buildAddQuery(query)));
}

std::unique_ptr<QueryEngine::Query>
QueryExecutorBuilderVisitor::buildAddQuery(const ADD_QUERY& query) {
	std::vector<std::unique_ptr<QueryEngine::Query>> subtaskQueries;
	std::vector<std::unique_ptr<QueryEngine::Query>> dependencyQueries;

	std::transform(begin(query.subtasks), end(query.subtasks),
		std::back_inserter(subtaskQueries), [](const ADD_QUERY& q) {
		return QueryExecutorBuilderVisitor::buildAddQuery(q);
	});

	ADD_QUERY dependentQuery = query;
	bool hasDependencies = false;
	while (dependentQuery.dependent) {
		hasDependencies = true;
		dependencyQueries.push_back(QueryEngine::AddTask(
			dependentQuery.description,
			dependentQuery.start ? dependentQuery.start.get()
								 : Task::DEFAULT_START_TIME,
			dependentQuery.deadline ? dependentQuery.deadline.get()
								    : Task::DEFAULT_DEADLINE,
			dependentQuery.priority == TaskPriority::HIGH ?
			Task::Priority::HIGH : Task::Priority::NORMAL,
			{}, {}));
		if (dependentQuery.dependent) {
			dependentQuery = *dependentQuery.dependent;
		}
	}


	ADD_QUERY addQuery = hasDependencies ? dependentQuery : query;
	return QueryEngine::AddTask(
		addQuery.description,
		addQuery.start ? addQuery.start.get() : Task::DEFAULT_START_TIME,
		addQuery.deadline ? addQuery.deadline.get() : Task::DEFAULT_DEADLINE,
		addQuery.priority == TaskPriority::HIGH ?
		Task::Priority::HIGH : Task::Priority::NORMAL,
		std::move(dependencyQueries),
		std::move(subtaskQueries)
	);
}

std::unique_ptr<QueryExecutor>
QueryExecutorBuilderVisitor::build(const SHOW_QUERY& query) {
	class ShowTaskQueryExecutor : public QueryExecutor {
	public:
		explicit ShowTaskQueryExecutor(
			std::unique_ptr<QueryEngine::Query>&& query)
			: QueryExecutor(std::move(query)) {
		}

		virtual ~ShowTaskQueryExecutor() = default;

	protected:
		Result processResponse(
			const You::QueryEngine::Response& response) override {
			return SHOW_RESULT {
				boost::get<TaskList>(response)
			};
		}
	};

	using You::QueryEngine::Filter;
	using You::QueryEngine::Comparator;
	Filter filter = Filter::anyTask();
	Comparator comparator(Comparator::notSorted());

	std::for_each(begin(query.predicates), end(query.predicates),
		[&filter](const SHOW_QUERY::FIELD_FILTER& field) {
			std::function<bool(const Task&)> currentFilter;
			switch (field.field) {
			case TaskField::DESCRIPTION:
				assert(boost::get<std::wstring>(&field.value));
				currentFilter = buildComparator(&Task::getDescription,
					field.predicate,
					boost::get<std::wstring>(field.value));
				break;
			case TaskField::START:
				assert(boost::get<boost::posix_time::ptime>(&field.value));
				currentFilter = buildComparator(&Task::getStartTime,
					field.predicate,
					boost::get<boost::posix_time::ptime>(field.value));
				break;
			case TaskField::DEADLINE:
				assert(boost::get<boost::posix_time::ptime>(&field.value));
				currentFilter = buildComparator(&Task::getDeadline,
					field.predicate,
					boost::get<boost::posix_time::ptime>(field.value));
				break;
			case TaskField::COMPLETE:
				assert(boost::get<bool>(&field.value));
				currentFilter = buildComparator(&Task::isCompleted,
					field.predicate,
					boost::get<bool>(field.value));
				break;
			case TaskField::PRIORITY:
				assert(boost::get<TaskPriority>(&field.value));
				currentFilter = buildComparator(&Task::getPriority,
					field.predicate,
					Controller::nlpToQueryEnginePriority(
						boost::get<TaskPriority>(field.value)));
				break;
			default:
				fatal();
			}

			filter = filter && Filter(currentFilter);
		});

	std::for_each(begin(query.order), end(query.order),
		[&comparator](const SHOW_QUERY::FIELD_ORDER& field) {
			Comparator comp(Comparator::notSorted());
			switch (field.field) {
			case TaskField::DESCRIPTION:
				comp = Comparator::byDescription();
				break;
			case TaskField::START:
				comp = Comparator::byStartTime();
				break;
			case TaskField::DEADLINE:
				comp = Comparator::byDeadline();
				break;
			case TaskField::PRIORITY:
				comp = Comparator::byPriority();
				break;
			case TaskField::COMPLETE:
			default:
				fatal();
			}

			if (field.order == SHOW_QUERY::Order::ASCENDING) {
				comp = comp.ascending();
			} else {
				comp = comp.descending();
			}

			comparator = comparator && comp;
		});

	return std::unique_ptr<QueryExecutor>(
		new ShowTaskQueryExecutor(
			QueryEngine::GetTask(filter, comparator)
		)
	);
}

template<typename TValue>
std::function<bool(const Task&)>
QueryExecutorBuilderVisitor::buildComparator(
	TValue(QueryEngine::Task::*selector)() const,
	SHOW_QUERY::Predicate predicate,
	const TValue& value) {
	switch (predicate) {
	case SHOW_QUERY::Predicate::EQ:
		return std::bind(std::equal_to<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::SIMILAR:
		return std::bind(Utils::similar_to<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::NOT_EQ:
		return std::bind(std::not_equal_to<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::LESS_THAN:
		return std::bind(std::less<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::LESS_THAN_EQ:
		return std::bind(std::less_equal<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::GREATER_THAN:
		return std::bind(std::greater<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	case SHOW_QUERY::Predicate::GREATER_THAN_EQ:
		return std::bind(std::greater_equal<TValue>(),
			std::bind(selector, std::placeholders::_1),
			value);
	default:
		fatal();
	}
}

std::unique_ptr<QueryExecutor>
QueryExecutorBuilderVisitor::build(const EDIT_QUERY& query) const {
	class EditTaskQueryExecutor : public QueryExecutor {
	public:
		explicit EditTaskQueryExecutor(
			std::unique_ptr<QueryEngine::Query>&& query)
			: QueryExecutor(std::move(query)) {
		}

		virtual ~EditTaskQueryExecutor() = default;

	protected:
		Result processResponse(
			const You::QueryEngine::Response& response) override {
			return EDIT_RESULT {
				boost::get<Task>(response)
			};
		}
	};

	try {
		Task::ID task = context.at(query.taskID - 1).getID();
		You::Utils::Option<Task::Priority> priority;
		if (query.priority) {
			priority = Controller::nlpToQueryEnginePriority(
				query.priority.get());
		}

		typedef QueryEngine::Delta<Task::Attachment::value_type> Attachment;
		typedef QueryEngine::Delta<Task::Dependencies::value_type> Dependencies;
		typedef QueryEngine::Delta<Task::Subtasks::value_type> Subtasks;

		Subtasks subtasks;
		if (query.childTask) {
			assert(!query.description &&
				!query.deadline &&
				!priority &&
				!query.complete &&
				!query.dependingTask &&
				query.attachments.empty() &&
				"Cannot change subtasks with other properties");
			int childTask = query.childTask.get();
			if (childTask < 0) {
				subtasks.type = Subtasks::Type::DELETE;
				subtasks.elements = { context.at(-childTask - 1).getID() };
			} else {
				subtasks.type = Subtasks::Type::ADD;
				subtasks.elements = { context.at(childTask - 1).getID() };
			}
		}

		Dependencies dependencies;
		if (query.dependingTask) {
			assert(!query.description &&
				!query.deadline &&
				!priority &&
				!query.complete &&
				!query.childTask &&
				query.attachments.empty() &&
				"Cannot change dependencies with other properties");
			int dependingTask = query.dependingTask.get();
			if (dependingTask < 0) {
				dependencies.type = Dependencies::Type::DELETE;
				dependencies.elements = { task };
				task = context.at(-dependingTask - 1).getID();
			} else {
				dependencies.type = Dependencies::Type::ADD;
				dependencies.elements = { task };
				task = context.at(dependingTask - 1).getID();
			}
		}
		Attachment attachment;
		if (!query.attachments.empty()) {
			assert(!query.description &&
				!query.deadline &&
				!priority &&
				!query.complete &&
				!query.childTask &&
				!query.dependingTask &&
				"Cannot modify attachments with other properties");
			assert(query.attachments.size() == 1 &&
				"Controller currently only supports modifying one attachment "
				"at a time");
			std::for_each(begin(query.attachments), end(query.attachments),
				[&attachment] (const EDIT_QUERY::ATTACHMENT_ACTION& att) {
					if (att.add) {
						assert(attachment.type == Attachment::Type::ADD
							|| attachment.type == Attachment::Type::NO_CHANGE);
						attachment.type = Attachment::Type::ADD;
					} else {
						assert(attachment.type == Attachment::Type::DELETE
							|| attachment.type == Attachment::Type::NO_CHANGE);
						attachment.type = Attachment::Type::DELETE;
					}
					attachment.elements.emplace_back(std::move(att.path));
			});
		}

		return std::unique_ptr<QueryExecutor>(
			new EditTaskQueryExecutor(
				QueryEngine::UpdateTask(
					task,
					query.description,
					query.start,
					query.deadline,
					priority,
					dependencies,
					query.complete,
					boost::none,
					subtasks,
					attachment)));
	} catch (std::out_of_range& e) {
		throw ContextIndexOutOfRangeException(e);
	}
}

std::unique_ptr<QueryExecutor>
QueryExecutorBuilderVisitor::build(const DELETE_QUERY& query) const {
	class DeleteTaskQueryExecutor : public QueryExecutor {
	public:
		explicit DeleteTaskQueryExecutor(
			std::unique_ptr<QueryEngine::Query>&& query)
			: QueryExecutor(std::move(query)) {
		}

		virtual ~DeleteTaskQueryExecutor() = default;

	protected:
		Result processResponse(
			const You::QueryEngine::Response& response) override {
			return DELETE_RESULT {
				boost::get<Task::ID>(response)
			};
		}
	};

	try {
		const Task& task = context.at(query.taskID - 1);

		return std::unique_ptr<QueryExecutor>(
			new DeleteTaskQueryExecutor(
				QueryEngine::DeleteTask(
					task.getID())));
	} catch (std::out_of_range& e) {
		throw ContextIndexOutOfRangeException(e);
	}
}

std::unique_ptr<QueryExecutor>
QueryExecutorBuilderVisitor::build(const UNDO_QUERY& /*query*/) const {
	class UndoTaskQueryExecutor : public QueryExecutor {
	public:
		explicit UndoTaskQueryExecutor(
			std::unique_ptr<QueryEngine::Query>&& query)
			: QueryExecutor(std::move(query)) {
		}

		virtual ~UndoTaskQueryExecutor() = default;

	protected:
		Result processResponse(
			const You::QueryEngine::Response& response) override {
			return UNDO_RESULT {
				boost::get<TaskList>(response)
			};
		}
	};

	return std::unique_ptr<QueryExecutor>(
		new UndoTaskQueryExecutor(
			QueryEngine::Undo()));
}

}  // namespace Internal
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller\internal\query_executor_builder_visitor.cpp





	/**
	 * origin: .\You-Controller\internal\query_executor_builder_visitor.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_BUILDER_VISITOR_H_
#define YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_BUILDER_VISITOR_H_

#include <memory>
#include <boost/variant.hpp>

#include "../controller_context.h"
#include "You-NLP/parse_tree.h"

namespace You {
namespace QueryEngine { class Query; }
namespace Controller {
namespace Internal {

/// The query executor builder that will convert a syntax tree from the
/// \ref You::NLP::QueryParser into a \ref QueryExecutor object.
class QueryExecutorBuilderVisitor : public boost::static_visitor<
	std::unique_ptr<class QueryExecutor>> {
public:
	/// Constructor. Specify the context for which the query is to be built
	/// with.
	explicit QueryExecutorBuilderVisitor(const Controller::Context& context);

	/// Visitor implementation.
	///
	/// \param[in] query The actual query from the parse tree.
	template<typename QueryType>
	std::unique_ptr<QueryExecutor> operator()(
		const QueryType& query) const {
		return build(query);
	}

private:
	QueryExecutorBuilderVisitor(const QueryExecutorBuilderVisitor&) = delete;
	QueryExecutorBuilderVisitor& operator=(
		const QueryExecutorBuilderVisitor&) = delete;

	/// Builds a query engine query from the given add syntax tree.
	///
	/// \param[in] query The syntax tree to build a query from.
	static std::unique_ptr<QueryExecutor>
		build(const You::NLP::ADD_QUERY& query);

	/// Builds a query engine query from the given add syntax tree. This will
	/// recursively convert subtasks.
	///
	/// \param[in] query The syntax tree to build a query from.
	static std::unique_ptr<You::QueryEngine::Query> buildAddQuery(
		const You::NLP::ADD_QUERY& query);

	/// Builds a query engine query from the given show syntax tree.
	///
	/// \param[in] query The syntax tree to build a query from.
	static std::unique_ptr<QueryExecutor>
		build(const You::NLP::SHOW_QUERY& query);

	/// Builds a query engine filter functor from the given task getter,
	/// predicate, and value to compare against.
	///
	/// \tparam TValue The return type of the getter.
	/// \param selector The selector to get the property of the task.
	/// \param predicate The predicate to use when comparing against the value.
	/// \param value The value to compare the task property against.
	template<typename TValue>
	static std::function<bool(const Task&)> buildComparator(
		TValue (QueryEngine::Task::*selector)() const,
		You::NLP::SHOW_QUERY::Predicate predicate,
		const TValue& value);

	/// Builds a query engine query from the given edit syntax tree.
	///
	/// \param[in] query The syntax tree to build a query from.
	std::unique_ptr<QueryExecutor>
		build(const You::NLP::EDIT_QUERY& query) const;

	/// Builds a query engine query from the given delete syntax tree.
	///
	/// \param[in] query The syntax tree to build a query from.
	std::unique_ptr<QueryExecutor>
		build(const You::NLP::DELETE_QUERY& query) const;

	/// Builds a query engine query from the given undo syntax tree.
	///
	/// \param[in] query The syntax tree to build a query from.
	std::unique_ptr<QueryExecutor>
		build(const You::NLP::UNDO_QUERY& query) const;

private:
	/// The context for the query.
	You::Controller::Controller::Context context;
};


}  // namespace Internal
}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_INTERNAL_QUERY_EXECUTOR_BUILDER_VISITOR_H_

	// End of segment: .\You-Controller\internal\query_executor_builder_visitor.h





	/**
	 * origin: .\You-Controller\result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULT_H_
#define YOU_CONTROLLER_RESULT_H_

#include <vector>
#include "You-QueryEngine/api.h"

namespace You {
namespace Controller {

/// Defines the type of a task.
typedef QueryEngine::Task Task;

/// Defines the type of a task list.
typedef std::vector<Task> TaskList;

/// Defines the query engine utility class.
typedef You::QueryEngine::QueryEngine QueryEngine;

}  // namespace Controller
}  // namespace You

#include "results/add_result.h"
#include "results/show_result.h"
#include "results/delete_result.h"
#include "results/edit_result.h"
#include "results/undo_result.h"
#include "results/result.h"

#endif  // YOU_CONTROLLER_RESULT_H_

	// End of segment: .\You-Controller\result.h





	/**
	 * origin: .\You-Controller\results\add_result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_ADD_RESULT_H_
#define YOU_CONTROLLER_RESULTS_ADD_RESULT_H_

namespace You {
namespace Controller {

/// Defines the result of an Add query.
struct ADD_RESULT {
	/// The task which was added.
	Task task;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_ADD_RESULT_H_

	// End of segment: .\You-Controller\results\add_result.h





	/**
	 * origin: .\You-Controller\results\delete_result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_DELETE_RESULT_H_
#define YOU_CONTROLLER_RESULTS_DELETE_RESULT_H_

namespace You {
namespace Controller {

/// Defines the result of a Delete query.
struct DELETE_RESULT {
	/// The Task ID which was deleted.
	Task::ID task;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_DELETE_RESULT_H_

	// End of segment: .\You-Controller\results\delete_result.h





	/**
	 * origin: .\You-Controller\results\edit_result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_EDIT_RESULT_H_
#define YOU_CONTROLLER_RESULTS_EDIT_RESULT_H_

namespace You {
namespace Controller {

/// Defines the result of an Edit query.
struct EDIT_RESULT {
	/// The new, modified task. The task ID is guaranteed to be the same.
	Task task;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_EDIT_RESULT_H_

	// End of segment: .\You-Controller\results\edit_result.h





	/**
	 * origin: .\You-Controller\results\result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_RESULT_H_
#define YOU_CONTROLLER_RESULTS_RESULT_H_

#include <boost/variant.hpp>

namespace You {
namespace Controller {

/// Defines the type of the result from running a string query.
typedef boost::variant<
	ADD_RESULT,
	SHOW_RESULT,
	EDIT_RESULT,
	DELETE_RESULT,
	UNDO_RESULT
> Result;

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_RESULT_H_

	// End of segment: .\You-Controller\results\result.h





	/**
	 * origin: .\You-Controller\results\show_result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_SHOW_RESULT_H_
#define YOU_CONTROLLER_RESULTS_SHOW_RESULT_H_

namespace You {
namespace Controller {

/// Defines the result of a Show query.
struct SHOW_RESULT {
	/// The tasks which were retrieved
	TaskList tasks;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_SHOW_RESULT_H_


	// End of segment: .\You-Controller\results\show_result.h





	/**
	 * origin: .\You-Controller\results\undo_result.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_RESULTS_UNDO_RESULT_H_
#define YOU_CONTROLLER_RESULTS_UNDO_RESULT_H_

namespace You {
namespace Controller {

/// Defines the result of an Undo query.
struct UNDO_RESULT {
	TaskList tasks;
};

}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_RESULTS_UNDO_RESULT_H_

	// End of segment: .\You-Controller\results\undo_result.h





	/**
	 * origin: .\You-Controller-Tests\controller_context_tests.cpp
	 */

#include "stdafx.h"
#include "exception.h"
#include "controller_context.h"
#include "mocks/task_list.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace Controller {
namespace UnitTests {

using You::Controller::ContextRequiredException;

TEST_CLASS(ControllerContextTests) {
public:
	TEST_METHOD(defaultIsADefaultContext) {
		Assert::IsTrue(Controller::Context::DEFAULT.isDefault());
	}

	TEST_METHOD(taskListIsNotADefaultContext) {
		TaskList list;
		Controller::Context controllerContext(list);
		Assert::IsFalse(controllerContext.isDefault());
	}

	TEST_METHOD(throwsContextRequiredExceptionWhenDefaultIsUsed) {
		Assert::ExpectException<ContextRequiredException>(
			std::bind(
				&Controller::Context::at,
				Controller::Context::DEFAULT,
				0),
			L"Default context throws exception when used.");

		Assert::ExpectException<ContextRequiredException>(
			std::bind(
				&Controller::Context::operator[],
				Controller::Context::DEFAULT,
				0),
			L"Default context throws exception when used.");
	}

	TEST_METHOD(atThrowsOutOfRangeWhenUsedWithInvalidIndex) {
		TaskList list;
		Controller::Context controllerContext(list);

		Assert::ExpectException<std::out_of_range>(
			std::bind(&Controller::Context::at, controllerContext, 0),
			L"at throws exception when used with invalid index.");
	}

	TEST_METHOD(atAndArrayAccessReturnsCorrectItem) {
		Mocks::TaskList taskList;
		Controller::Context context(taskList);

		// TODO(lowjoel): Use AreEqual when there's an accessible ToString
		Assert::IsTrue(taskList.front() == context[0]);
		Assert::IsTrue(taskList.front() == context.at(0));
	}
};

}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\controller_context_tests.cpp





	/**
	 * origin: .\You-Controller-Tests\controller_tests.cpp
	 */

#include "stdafx.h"
#include "controller.h"
#include "controller_context.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace Microsoft {
namespace VisualStudio {
namespace CppUnitTestFramework {

std::wstring ToString(const You::Controller::Controller& value) {
	return ToString(static_cast<const void*>(&value));
}

}  // namespace CppUnitTestFramework
}  // namespace VisualStudio
}  // namespace Microsoft

namespace You {
namespace Controller {
namespace UnitTests {

TEST_CLASS(ControllerTests) {
	TEST_METHOD(controllerIsSingleton) {
		Assert::AreSame(
			Controller::get(),
			Controller::get());
	}

	TEST_METHOD(query) {
		ADD_RESULT result = boost::get<ADD_RESULT>(
			Controller::get().query(L"/add hello",
			Controller::Context::DEFAULT));

		Assert::AreEqual(std::wstring(L"hello"), result.task.getDescription());
	}

	TEST_METHOD(getAllTasks) {
		Controller::get().getTasks();
	}

	TEST_METHOD(getSomeTasks) {
		Controller::get().getTasks({});
	}
};

}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\controller_tests.cpp





	/**
	 * origin: .\You-Controller-Tests\exceptions\context_index_out_of_range_exception_tests.cpp
	 */

#include "stdafx.h"
#include "exceptions/context_index_out_of_range_exception.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace Controller {
namespace UnitTests {

TEST_CLASS(ContextIndexOutOfRangeExceptionTests) {
public:
	TEST_METHOD(contextIndexOutOfRangeExceptionIsAControllerException) {
		Assert::ExpectException<Exception>([]() {
			throw ContextIndexOutOfRangeException();
		});
	}

	TEST_METHOD(contextIndexOutOfRangeExceptionIsAnOutOfRange) {
		Assert::ExpectException<std::out_of_range>([]() {
			throw ContextIndexOutOfRangeException();
		});
	}
};

}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\exceptions\context_index_out_of_range_exception_tests.cpp





	/**
	 * origin: .\You-Controller-Tests\internal\query_executor_builder_visitor_tests.cpp
	 */

#include "stdafx.h"
#include "You-NLP/parse_tree/task_priority.h"
#include "internal/query_executor.h"
#include "internal/query_executor_builder_visitor.h"
#include "exceptions/context_index_out_of_range_exception.h"

#include "../mocks/task_list.h"
#include "../mocks/query.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace Microsoft {
namespace VisualStudio {
namespace CppUnitTestFramework {

std::wstring ToString(You::Controller::Task::Priority priority) {
	return ToString(static_cast<int>(priority));
}

}  // namespace CppUnitTestFramework
}  // namespace VisualStudio
}  // namespace Microsoft

namespace You {
namespace Controller {
namespace Internal {
namespace UnitTests {

namespace Mocks {
	// NOLINTNEXTLINE(build/namespaces)
	using namespace You::Controller::UnitTests::Mocks;
}

using Task = You::Controller::Task;
using TaskPriority = You::NLP::TaskPriority;

TEST_CLASS(QueryExecutorBuilderVisitorTests) {
	TEST_METHOD(getsCorrectTypeForAddQueries) {
		Mocks::TaskList taskList;
		QueryExecutorBuilderVisitor visitor(taskList);

		You::NLP::QUERY query(Mocks::Queries::ADD_QUERY);
		std::unique_ptr<QueryExecutor> executor(
			boost::apply_visitor(visitor, query));
		ADD_RESULT result(
			boost::get<ADD_RESULT>(executor->execute()));

		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.description,
			result.task.getDescription());
		Assert::AreEqual(
			Task::Priority::NORMAL,
			result.task.getPriority());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.start.get(),
			result.task.getStartTime());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.deadline.get(),
			result.task.getDeadline());

		You::NLP::ADD_QUERY queryWithoutStart(Mocks::Queries::ADD_QUERY);
		queryWithoutStart.start = boost::none;
		query = queryWithoutStart;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());

		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.description,
			result.task.getDescription());
		Assert::AreEqual(
			Task::Priority::NORMAL,
			result.task.getPriority());
		Assert::AreEqual(
			Task::DEFAULT_START_TIME,
			result.task.getStartTime());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.deadline.get(),
			result.task.getDeadline());

		You::NLP::ADD_QUERY queryWithoutDeadline(Mocks::Queries::ADD_QUERY);
		queryWithoutDeadline.deadline = boost::none;
		query = queryWithoutDeadline;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());

		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.description,
			result.task.getDescription());
		Assert::AreEqual(
			Task::Priority::NORMAL,
			result.task.getPriority());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.start.get(),
			result.task.getStartTime());
		Assert::AreEqual(
			Task::DEFAULT_DEADLINE,
			result.task.getDeadline());

		You::NLP::ADD_QUERY queryWithPriority(Mocks::Queries::ADD_QUERY);
		queryWithPriority.priority = TaskPriority::HIGH;
		query = queryWithPriority;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());

		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.description,
			result.task.getDescription());
		Assert::AreEqual(
			Task::Priority::HIGH,
			result.task.getPriority());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.start.get(),
			result.task.getStartTime());
		Assert::AreEqual(
			Mocks::Queries::ADD_QUERY.deadline.get(),
			result.task.getDeadline());

		You::NLP::ADD_QUERY queryWithSubtask(Mocks::Queries::ADD_QUERY);
		queryWithSubtask.subtasks = {
			You::NLP::ADD_QUERY {
				Mocks::Queries::ADD_QUERY.description + L"S"
			}
		};
		query = queryWithSubtask;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());

		Assert::IsFalse(result.task.getSubtasks().empty());

		You::NLP::ADD_QUERY queryWithDependency(Mocks::Queries::ADD_QUERY);
		queryWithDependency.dependent = std::make_shared<NLP::ADD_QUERY>(
			NLP::ADD_QUERY {
				Mocks::Queries::ADD_QUERY.description + L"D"
			});
		query = queryWithDependency;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());
		Assert::AreEqual(result.task.getDependenciesObject().size(),
			static_cast<std::size_t>(1));
		Assert::AreEqual(
			result.task.getDependenciesObject().at(0).getDescription(),
				Task::Description(L"wow"));

		queryWithDependency.dependent->dependent =
			std::make_shared<NLP::ADD_QUERY>(
				NLP::ADD_QUERY {
					Mocks::Queries::ADD_QUERY.description + L"E"
				});

		query = queryWithDependency;
		executor = boost::apply_visitor(visitor, query);
		result = boost::get<ADD_RESULT>(executor->execute());
		Assert::IsFalse(result.task.getDependenciesObject().empty());
		Assert::AreEqual(result.task.
				getDependenciesObject().at(0).
				getDependenciesObject().at(0).getDescription(),
				Task::Description(L"wow"));
	}

	TEST_METHOD(getsCorrectTypeForShowQueries) {
		SHOW_RESULT result(
			runShowQuery(Mocks::Queries::SHOW_QUERY));
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
			[](const Task& task) {
			return task.getDeadline() >
				boost::get<boost::posix_time::ptime>(
					Mocks::Queries::SHOW_QUERY.predicates[0].value);
		}));
		Assert::IsTrue(
			std::is_sorted(begin(result.tasks), end(result.tasks),
			[](const Task& left, const Task& right) {
			return left.getDeadline() > right.getDeadline();
		}));

		result = runShowQuery(
			You::NLP::SHOW_QUERY {
				{
					{
						You::NLP::TaskField::PRIORITY,
						You::NLP::SHOW_QUERY::Predicate::EQ,
						You::NLP::TaskPriority::NORMAL
					}
				},
				{
					{
						You::NLP::TaskField::DESCRIPTION,
						You::NLP::SHOW_QUERY::Order::ASCENDING
					}
				}
			});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
			std::bind(
				std::equal_to<You::QueryEngine::Task::Priority>(),
				std::bind(&Task::getPriority, std::placeholders::_1),
				You::QueryEngine::Task::Priority::NORMAL)));
		Assert::IsTrue(
			std::is_sorted(begin(result.tasks), end(result.tasks),
			[](const Task& left, const Task& right) {
			return left.getDescription() < right.getDescription();
		}));

		result = runShowQuery(
			You::NLP::SHOW_QUERY {
				{
					{
						You::NLP::TaskField::COMPLETE,
						You::NLP::SHOW_QUERY::Predicate::EQ,
						false
					}
				},
				{
					{
						You::NLP::TaskField::PRIORITY,
						You::NLP::SHOW_QUERY::Order::DESCENDING
					}
				}
			});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::not_equal_to<bool>(),
					std::bind(&Task::isCompleted, std::placeholders::_1),
					true)));
		Assert::IsTrue(
			std::is_sorted(begin(result.tasks), end(result.tasks),
				std::bind(
					std::greater<Task::Priority>(),
					std::bind(&Task::getPriority, std::placeholders::_1),
					std::bind(&Task::getPriority, std::placeholders::_1))));

		appliesCorrectFilters();
	}

	void appliesCorrectFilters() {
		// Test filters more rigourously
		appliesCorrectFilters<You::NLP::TaskField::DESCRIPTION>(
			std::bind(&Task::getDescription, std::placeholders::_1),
			std::wstring(L"meh 1"));

		auto runTime = boost::posix_time::second_clock::local_time();
		appliesCorrectFilters<You::NLP::TaskField::START>(
			std::bind(&Task::getStartTime, std::placeholders::_1),
			runTime - boost::posix_time::hours(1));

		appliesCorrectFilters<You::NLP::TaskField::DEADLINE>(
			std::bind(&Task::getDeadline, std::placeholders::_1),
			runTime + boost::posix_time::hours(1));

		appliesCorrectFilters<You::NLP::TaskField::COMPLETE>(
			std::bind(&Task::isCompleted, std::placeholders::_1),
			true);

		appliesCorrectFilters<You::NLP::TaskField::PRIORITY>(
			[](const Task& task) {
				return Controller::queryEngineToNlpPriority(
					task.getPriority());
			},
			You::NLP::TaskPriority::HIGH);
	}

	/// This is a very useful template function. Because it tests all 7
	/// operators: equality, inequality, less than, less than or equal,
	/// greater than, greater or equal on a type all at once.
	///
	/// \tparam field The field to access
	/// \param getter The getter to access the record in the object.
	/// \param value The value to compare against.
	template<You::NLP::TaskField field, typename TGetter, typename TValue>
	void appliesCorrectFilters(TGetter getter, const TValue& value) {
		SHOW_RESULT result(runShowQuery(You::NLP::SHOW_QUERY {
				{ { field, You::NLP::SHOW_QUERY::Predicate::EQ, value } }, {}
			}));
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::equal_to<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));

		result = runShowQuery(You::NLP::SHOW_QUERY {
			{ { field, You::NLP::SHOW_QUERY::Predicate::NOT_EQ, value } }, {}
		});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::not_equal_to<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));

		result = runShowQuery(You::NLP::SHOW_QUERY {
			{ { field, You::NLP::SHOW_QUERY::Predicate::LESS_THAN, value } }, {}
		});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::less<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));

		result = runShowQuery(You::NLP::SHOW_QUERY {
			{ {
				field,
				You::NLP::SHOW_QUERY::Predicate::LESS_THAN_EQ,
				value
			} }, {}
		});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::less_equal<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));

		result = runShowQuery(You::NLP::SHOW_QUERY {
			{ {
				field,
				You::NLP::SHOW_QUERY::Predicate::GREATER_THAN,
				value }
			}, {}
		});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::greater<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));

		result = runShowQuery(You::NLP::SHOW_QUERY {
			{ {
				field,
				You::NLP::SHOW_QUERY::Predicate::GREATER_THAN_EQ,
				value
			} }, {}
		});
		Assert::IsTrue(
			std::all_of(begin(result.tasks), end(result.tasks),
				std::bind(
					std::greater_equal<TValue>(),
					std::bind(getter, std::placeholders::_1),
					value)));
	}

	SHOW_RESULT runShowQuery(const You::NLP::QUERY& query) {
		Mocks::TaskList taskList(5);
		QueryExecutorBuilderVisitor visitor(taskList);

		std::unique_ptr<QueryExecutor> executor =
			boost::apply_visitor(visitor, query);
		return boost::get<SHOW_RESULT>(executor->execute());
	}

	TEST_METHOD(getsCorrectTypeForEditQueries) {
		NLP::EDIT_QUERY query = Mocks::Queries::EDIT_QUERY;
		executesEditQueryProperly(query);

		query.description = boost::none;
		executesEditQueryProperly(query);

		query = Mocks::Queries::EDIT_QUERY;
		query.priority = boost::none;
		executesEditQueryProperly(query);

		query = Mocks::Queries::EDIT_QUERY;
		query.start = boost::none;
		executesEditQueryProperly(query);

		query = Mocks::Queries::EDIT_QUERY;
		query.deadline = boost::none;
		executesEditQueryProperly(query);

		query = Mocks::Queries::EDIT_QUERY;
		query.complete = boost::none;
		executesEditQueryProperly(query);

		query = NLP::EDIT_QUERY {};
		query.taskID = Mocks::Queries::EDIT_QUERY.taskID;
		query.childTask = 2;
		executesEditQueryProperly(query);

		query.childTask = -2;
		executesEditQueryProperly(query);

		query = NLP::EDIT_QUERY {};
		query.taskID = Mocks::Queries::EDIT_QUERY.taskID;
		query.dependingTask = 2;
		executesEditQueryProperly(query);

		query.dependingTask = -2;
		executesEditQueryProperly(query);

		query = NLP::EDIT_QUERY {};
		query.taskID = Mocks::Queries::EDIT_QUERY.taskID;
		query.attachments.push_back({ true, L"test" });
		executesEditQueryProperly(query);

		query = NLP::EDIT_QUERY {};
		query.taskID = Mocks::Queries::EDIT_QUERY.taskID;
		query.attachments.push_back({ false, L"test" });
		executesEditQueryProperly(query);
	}

	void executesEditQueryProperly(const NLP::EDIT_QUERY& editQuery) {
		Mocks::TaskList taskList(5);
		QueryExecutorBuilderVisitor visitor(taskList);
		Task& first = taskList.front();

		You::NLP::QUERY query = editQuery;
		std::unique_ptr<QueryExecutor> executor(
			boost::apply_visitor(visitor, query));
		EDIT_RESULT result(
			boost::get<EDIT_RESULT>(executor->execute()));

		if (editQuery.dependingTask) {
			Assert::AreNotEqual(first.getID(), result.task.getID());
			if (editQuery.dependingTask.get() > 0) {
				Assert::IsFalse(result.task.getDependencies().empty());
			}
		} else {
			Assert::AreEqual(first.getID(), result.task.getID());
			Assert::AreEqual(editQuery.description ?
				editQuery.description.get() : first.getDescription(),
				result.task.getDescription());
			Assert::AreEqual(editQuery.priority ?
				Controller::nlpToQueryEnginePriority(editQuery.priority.get()) :
				first.getPriority(),
				result.task.getPriority());
			Assert::AreEqual(editQuery.start ?
				editQuery.start.get() : first.getStartTime(),
				result.task.getStartTime());
			Assert::AreEqual(editQuery.deadline ?
				editQuery.deadline.get() : first.getDeadline(),
				result.task.getDeadline());
			Assert::AreEqual(editQuery.complete ?
				editQuery.complete.get() : first.isCompleted(),
				result.task.isCompleted());
			if (editQuery.childTask) {
				if (editQuery.childTask.get() > 0) {
					Assert::AreEqual(first.getSubtasks().size() + 1,
						result.task.getSubtasks().size());
				}
			} else {
				Assert::AreEqual(first.getSubtasks().size(),
					result.task.getSubtasks().size());
			}
			Assert::AreEqual(
				first.getDependencies().size(),
				result.task.getDependencies().size());
			if (!editQuery.attachments.empty()) {
				assert(editQuery.attachments.size() == 1);
				Task::Attachment resultAttachment =
					result.task.getAttachment();
				if (editQuery.attachments[0].add) {
					Assert::IsTrue(
						std::find(begin(resultAttachment), end(resultAttachment),
							editQuery.attachments[0].path) != end(resultAttachment));
				} else {
					Assert::IsTrue(
						std::all_of(begin(resultAttachment), end(resultAttachment),
							std::bind(std::not_equal_to<std::wstring>(),
									  editQuery.attachments[0].path,
								      std::placeholders::_1)));
				}
			}
		}
	}

	TEST_METHOD(editQueriesOutOfBoundsThrowsContextOutOfRange) {
		Mocks::TaskList taskList(0);
		QueryExecutorBuilderVisitor visitor(taskList);

		You::NLP::QUERY query(Mocks::Queries::EDIT_QUERY);
		Assert::ExpectException<ContextIndexOutOfRangeException>([&]() {
			boost::apply_visitor(visitor, query);
		});
	}

	TEST_METHOD(getsCorrectTypeForDeleteQueries) {
		Mocks::TaskList taskList;
		QueryExecutorBuilderVisitor visitor(taskList);

		You::NLP::QUERY query(Mocks::Queries::DELETE_QUERY);
		std::unique_ptr<QueryExecutor> executor(
			boost::apply_visitor(visitor, query));
		DELETE_RESULT result(
			boost::get<DELETE_RESULT>(executor->execute()));

		Assert::AreEqual(taskList.front().getID(),
			result.task);
	}

	TEST_METHOD(deleteQueriesOutOfBoundsThrowsContextOutOfRange) {
		Mocks::TaskList taskList(0);
		QueryExecutorBuilderVisitor visitor(taskList);

		You::NLP::QUERY query(Mocks::Queries::DELETE_QUERY);
		Assert::ExpectException<ContextIndexOutOfRangeException>([&]() {
			boost::apply_visitor(visitor, query);
		});
	}

	TEST_METHOD(getsCorrectTypeForUndoQueries) {
		Mocks::TaskList taskList;
		QueryExecutorBuilderVisitor visitor(taskList);

		You::NLP::QUERY query(Mocks::Queries::UNDO_QUERY);
		std::unique_ptr<QueryExecutor> executor(
			boost::apply_visitor(visitor, query));
		UNDO_RESULT result(
			boost::get<UNDO_RESULT>(executor->execute()));

		// TODO(lowjoel): test for..?
	}
};

}  // namespace UnitTests
}  // namespace Internal
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\internal\query_executor_builder_visitor_tests.cpp





	/**
	 * origin: .\You-Controller-Tests\internal\query_executor_tests.cpp
	 */

#include "stdafx.h"
#include "internal/query_executor.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace Controller {
namespace Internal {
namespace UnitTests {

/// A dummy query executor which works like a AddQueryExecutor. This is just
/// for testing.
class DummyQueryExecutor : public QueryExecutor {
	friend class QueryExecutorTests;

public:
	/// Constructor. This creates an executor from a query returned by
	/// the Query Engine.
	explicit DummyQueryExecutor(
		std::unique_ptr<QueryEngine::Query>&& query)
		: QueryExecutor(std::move(query)) {
	}

	virtual ~DummyQueryExecutor() = default;

protected:
	Result processResponse(
		const You::QueryEngine::Response& response) override {
		return ADD_RESULT {
			boost::get<Task>(response)
		};
	}
};

TEST_CLASS(QueryExecutorTests) {
	TEST_METHOD(storesQuery) {
		std::unique_ptr<QueryEngine::Query> query(
			QueryEngine::GetTask(QueryEngine::Filter::anyTask()));

		DummyQueryExecutor executor(std::move(query));
		Assert::IsNotNull(executor.query.get());
	}

	TEST_METHOD(addTasksGetsTask) {
		std::unique_ptr<QueryEngine::Query> query(
			QueryEngine::AddTask(
				L"yay",
				QueryEngine::Task::DEFAULT_START_TIME,
				QueryEngine::Task::DEFAULT_DEADLINE,
				QueryEngine::Task::DEFAULT_PRIORITY,
				{},
				{}));

		DummyQueryExecutor executor(std::move(query));
		ADD_RESULT result = boost::get<ADD_RESULT>(executor.execute());
		Assert::AreEqual(std::wstring(L"yay"), result.task.getDescription());
	}
};

}  // namespace UnitTests
}  // namespace Internal
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\internal\query_executor_tests.cpp





	/**
	 * origin: .\You-Controller-Tests\mocks\query.cpp
	 */

#include "stdafx.h"
#include "query.h"

namespace You {
namespace Controller {
namespace UnitTests {
namespace Mocks {
namespace Queries {

extern const You::NLP::ADD_QUERY ADD_QUERY {
	L"wow",
	You::NLP::TaskPriority::NORMAL,
	boost::posix_time::ptime(
		boost::gregorian::date(2014, boost::gregorian::Sep, 15)),
	boost::posix_time::ptime(
		boost::gregorian::date(2014, boost::gregorian::Oct, 1))
};

extern const You::NLP::SHOW_QUERY SHOW_QUERY {
	{
		{
			You::NLP::TaskField::DEADLINE,
			You::NLP::SHOW_QUERY::Predicate::GREATER_THAN,
			boost::posix_time::second_clock::local_time() +
				boost::posix_time::hours(1),
		}
	},
	{
		{
			You::NLP::TaskField::DEADLINE,
			You::NLP::SHOW_QUERY::Order::DESCENDING
		}
	}
};

extern const You::NLP::EDIT_QUERY EDIT_QUERY {
	1,
	L"new description",
	You::NLP::TaskPriority::NORMAL,
	boost::none,
	boost::posix_time::ptime(
		boost::gregorian::date(2014, boost::gregorian::Oct, 1),
		boost::posix_time::hours(1) + boost::posix_time::minutes(1)
	),
	true
};

extern const You::NLP::DELETE_QUERY DELETE_QUERY {
	1
};

extern const You::NLP::UNDO_QUERY UNDO_QUERY {
};

}  // namespace Queries
}  // namespace Mocks
}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\mocks\query.cpp





	/**
	 * origin: .\You-Controller-Tests\mocks\query.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_TESTS_MOCKS_QUERY_H_
#define YOU_CONTROLLER_TESTS_MOCKS_QUERY_H_

#include "You-NLP/parse_tree.h"

namespace You {
namespace Controller {
namespace UnitTests {
namespace Mocks {
namespace Queries {

/// A default Add Query.
extern const You::NLP::ADD_QUERY ADD_QUERY;

/// A default Show Query.
extern const You::NLP::SHOW_QUERY SHOW_QUERY;

/// A default Edit Query.
extern const You::NLP::EDIT_QUERY EDIT_QUERY;

/// A default Edit Query.
extern const You::NLP::DELETE_QUERY DELETE_QUERY;

/// A default Undo Query.
extern const You::NLP::UNDO_QUERY UNDO_QUERY;

}  // namespace Queries
}  // namespace Mocks
}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_TESTS_MOCKS_QUERY_H_

	// End of segment: .\You-Controller-Tests\mocks\query.h





	/**
	 * origin: .\You-Controller-Tests\mocks\task_list.cpp
	 */

#include "stdafx.h"
#include <random>
#include "task_list.h"

namespace You {
namespace Controller {
namespace UnitTests {
namespace Mocks {

TaskList::TaskList(size_t count) {
	std::generate_n(std::back_inserter<TaskList>(*this),
		count, std::bind(&TaskList::createTask, this));
}

Task TaskList::createTask() {
	std::default_random_engine generator;
	std::uniform_int_distribution<int> distribution(0, 1);

	std::unique_ptr<QueryEngine::Query> q = QueryEngine::AddTask(
		L"meh " + boost::lexical_cast<std::wstring>(size()),
		QueryEngine::Task::DEFAULT_START_TIME,
		boost::posix_time::second_clock::local_time() +
			boost::posix_time::hours(size()),
			static_cast<QueryEngine::Task::Priority>(distribution(generator)),
		{}, {});

	QueryEngine::Response r = QueryEngine::executeQuery(std::move(q));
	return boost::get<Task>(r);
}

}  // namespace Mocks
}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

	// End of segment: .\You-Controller-Tests\mocks\task_list.cpp





	/**
	 * origin: .\You-Controller-Tests\mocks\task_list.h
	 */

#pragma once
#ifndef YOU_CONTROLLER_TESTS_MOCKS_TASK_LIST_H_
#define YOU_CONTROLLER_TESTS_MOCKS_TASK_LIST_H_

#include "result.h"

namespace You {
namespace Controller {
namespace UnitTests {
namespace Mocks {

/// A dummy task list. This contains one task.
class TaskList : public You::Controller::TaskList {
public:
	/// Constructor. Creates the specified number of tasks.
	explicit TaskList(size_t count = 1);

private:
	/// Creates a new task and adds it to the task list.
	Task createTask();
};

}  // namespace Mocks
}  // namespace UnitTests
}  // namespace Controller
}  // namespace You

#endif  // YOU_CONTROLLER_TESTS_MOCKS_TASK_LIST_H_

	// End of segment: .\You-Controller-Tests\mocks\task_list.h





	/**
	 * origin: .\You-DataStore\internal\pugixml.h
	 */

#pragma once
#ifndef YOU_DATASTORE_INTERNAL_PUGIXML_H
#define YOU_DATASTORE_INTERNAL_PUGIXML_H

#define PUGIXML_WCHAR_MODE
#include "pugixml.hpp"

#endif  // YOU_DATASTORE_INTERNAL_PUGIXML_H

	// End of segment: .\You-DataStore\internal\pugixml.h





	/**
	 * origin: .\You-DataStore\transaction.cpp
	 */

#include "stdafx.h"
#include "internal/internal_transaction.h"
#include "transaction.h"

namespace You {
namespace DataStore {

Transaction::Transaction()
: std::shared_ptr<Internal::Transaction>(
	std::make_shared<Internal::Transaction>()) {
}

Transaction::Transaction(Transaction&& t) {
	state = t.state;
	std::shared_ptr<Internal::Transaction>::operator=(std::move(t));
}

Transaction::~Transaction() {
	if (get() != nullptr && state == State::NEITHER) {
		rollback();
	}
}

void Transaction::commit() {
	assert(state == State::NEITHER);

	operator->()->commit();
	state = State::COMMITTED;
}

void Transaction::rollback() {
	assert(state == State::NEITHER);

	operator->()->rollback();
	state = State::ROLLED_BACK;
}

}  // namespace DataStore
}  // namespace You

	// End of segment: .\You-DataStore\transaction.cpp





	/**
	 * origin: .\You-DataStore\transaction.h
	 */

#pragma once
#ifndef YOU_DATASTORE_TRANSACTION_H_
#define YOU_DATASTORE_TRANSACTION_H_

#include <memory>

namespace You {
namespace DataStore {
namespace UnitTests { class DataStoreApiTest; class DataStoreTest; }
namespace Internal { class DataStore; class Transaction; }

/// Represents a collection of operations that need to collectively succeed or
/// fail.
///
/// This is a RAII class. At the end of the method, if \ref commit is not
/// called, the transaction will be rolled back.
class Transaction : protected std::shared_ptr<Internal::Transaction> {
	friend class Internal::DataStore;
	friend class UnitTests::DataStoreApiTest;
	friend class UnitTests::DataStoreTest;

public:
	/// Move constructor. We only allow a transaction to have one strong
	/// reference. \see DataStore
	///
	/// Usage:
	///
	///     Transaction t(DataStore::get().begin());
	///
	/// \param[in] transaction The transaction returned from
	///						   DataStore::get().begin()
	Transaction(Transaction&& transaction);

	/// Destructor. Rolls back the active transaction if it has not been
	/// committed.
	~Transaction();

	/// Commits the set of operations made.
	/// Only the latest (innermost) transaction can be committed.
	void commit();

	/// Rolls back all the operations made.
	/// Only the latest (innermost) transaction can be rolled back.
	void rollback();

private:
	/// The state of the transaction.
	enum class State {
		/// The transaction has neither been committed nor rolled back.
		NEITHER = 0,

		/// The transaction has been committed.
		COMMITTED,

		/// The transaction has been rolled back.
		ROLLED_BACK
	};

private:
	/// Default constructor. This is meant to be called by \ref DataStore.
	Transaction();

	/// Disable the copy constructor.
	Transaction(const Transaction&) = delete;

	/// Disable the copy assignment.
	Transaction& operator=(const Transaction&) = delete;

private:
	/// The state of the transaction.
	State state;
};

}  // namespace DataStore
}  // namespace You

#endif  // YOU_DATASTORE_TRANSACTION_H_

	// End of segment: .\You-DataStore\transaction.h





	/**
	 * origin: .\You-GUI\qt_helpers.h
	 */

#pragma once
#ifndef YOU_GUI_QT_HELPERS_H_
#define YOU_GUI_QT_HELPERS_H_

#include <QString>
#include <boost/lexical_cast.hpp>

namespace boost {
namespace detail {

/// Partial template specialisation for converting to QString. This is modified
/// from the boost::lexical_cast implementation.
template<typename Source>
struct lexical_converter_impl<QString, Source> {
	typedef lexical_cast_stream_traits<Source, QString> stream_trait;

	typedef detail::lexical_istream_limited_src<
		BOOST_DEDUCED_TYPENAME stream_trait::char_type,
		BOOST_DEDUCED_TYPENAME stream_trait::traits,
		stream_trait::requires_stringbuf,
		stream_trait::len_t::value + 1
	> i_interpreter_type;

	/// Converts the given argument to a QString.
	static inline bool try_convert(const Source& arg, QString& result) {
		i_interpreter_type i_interpreter;

		// Disabling ADL, by directly specifying operators.
		if (!(i_interpreter.operator <<(arg)))
			return false;

		// Copy from the stream.
		result = QString::fromWCharArray(
			i_interpreter.cbegin(),
			i_interpreter.cend() - i_interpreter.cbegin());

		return true;
	}
};

}  // namespace detail
}  // namespace boost

/// operator<< overload for boost::lexical_cast to work with QStrings.
///
/// \param[in] stream The stream to write to
/// \param[in] str The string to write.
/// \return The stream given, for chaining.
inline std::wostream& operator<<(std::wostream& stream, const QString& str) {
	return stream << str.data();
}

/// operator>> overload for boost::lexical_cast to work with QStrings.
///
/// \param[in] stream The stream to read from
/// \param[in] str The string to write to.
/// \return The stream given, for chaining.
inline std::wistream& operator>>(std::wistream& stream, QString& str) {
	std::wstring temp;
	stream >> temp;

	str = QString::fromStdWString(temp);
	return stream;
}

#endif  // YOU_GUI_QT_HELPERS_H_

	// End of segment: .\You-GUI\qt_helpers.h





	/**
	 * origin: .\You-NLP\date_time_parser.cpp
	 */

#include "stdafx.h"
#include "exceptions/parse_error_exception.h"
#include "date_time_parser.h"

namespace You {
namespace NLP {

using ptime = boost::posix_time::ptime;
namespace qi = boost::spirit::qi;
namespace phoenix = boost::phoenix;

ptime DateTimeParser::parse(const StringType& string) {
	ptime result;
	if (parse(string, result)) {
		return result;
	} else {
		throw ParserException();
	}
}

bool DateTimeParser::parse(const StringType& string, ptime& result) {
	try {
		return qi::parse(
			begin(string),
			end(string),
			DateTimeParser() > qi::omit[*ParserCharTraits::blank] > qi::eoi,
			result);
	} catch (ParserExpectationFailure&) {
		return false;
	}
}

DateTimeParser::DateTimeParser() : DateTimeParser::base_type(start) {
	start %= (
		date[qi::_val = phoenix::construct<DateTime>(
			qi::_1,
			boost::posix_time::hours(0))
		]
	);
	BOOST_SPIRIT_DEBUG_NODE(start);

	#pragma region Primitive date component parsers
	year = (
		+ParserCharTraits::digit
	)[qi::_val = phoenix::bind(&DateTimeParser::parseFuzzyYear, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(year);

	monthNames.add
		(L"january", boost::gregorian::Jan)
		(L"jan", boost::gregorian::Jan)
		(L"february", boost::gregorian::Feb)
		(L"feb", boost::gregorian::Feb)
		(L"march", boost::gregorian::Mar)
		(L"mar", boost::gregorian::Mar)
		(L"april", boost::gregorian::Apr)
		(L"apr", boost::gregorian::Apr)
		(L"may", boost::gregorian::May)
		(L"june", boost::gregorian::Jun)
		(L"jun", boost::gregorian::Jun)
		(L"july", boost::gregorian::Jul)
		(L"jul", boost::gregorian::Jul)
		(L"august", boost::gregorian::Aug)
		(L"aug", boost::gregorian::Aug)
		(L"september", boost::gregorian::Sep)
		(L"sept", boost::gregorian::Sep)
		(L"sep", boost::gregorian::Sep)
		(L"october", boost::gregorian::Oct)
		(L"oct", boost::gregorian::Oct)
		(L"november", boost::gregorian::Nov)
		(L"nov", boost::gregorian::Nov)
		(L"december", boost::gregorian::Dec)
		(L"dec", boost::gregorian::Dec);
	monthNames.name("monthNames");

	month %= (
		qi::int_ |
		ParserCharTraits::no_case[monthNames]
	);
	month.name("month");

	weekDays.add
		(L"monday", boost::gregorian::Monday)
		(L"mon", boost::gregorian::Monday)
		(L"tuesday", boost::gregorian::Tuesday)
		(L"tue", boost::gregorian::Tuesday)
		(L"wednesday", boost::gregorian::Wednesday)
		(L"wed", boost::gregorian::Wednesday)
		(L"thursday", boost::gregorian::Thursday)
		(L"thu", boost::gregorian::Thursday)
		(L"friday", boost::gregorian::Friday)
		(L"fri", boost::gregorian::Friday)
		(L"saturday", boost::gregorian::Saturday)
		(L"sat", boost::gregorian::Saturday)
		(L"sunday", boost::gregorian::Sunday)
		(L"sun", boost::gregorian::Sunday);
		weekDays.name("weekDays");

	day %= (
		qi::int_
	);
	BOOST_SPIRIT_DEBUG_NODE(day);
	#pragma endregion

	space = qi::omit[+ParserCharTraits::blank];

	#pragma region Supported Date Formats
	dateYearMonthDay = (
		year >> (space | '-') >> month >> (space | '-') >> day
	)[qi::_val = phoenix::construct<Date>(qi::_1, qi::_2, qi::_3)];
	BOOST_SPIRIT_DEBUG_NODE(dateYearMonthDay);

	dateYearMonth = (
		year >> '-' >> month
	)[qi::_val = phoenix::construct<Date>(qi::_1, qi::_2, 1)];
	BOOST_SPIRIT_DEBUG_NODE(dateYearMonth);

	dateYear = (
		year
	)[qi::_val = phoenix::construct<Date>(qi::_1, boost::gregorian::Jan, 1)];
	BOOST_SPIRIT_DEBUG_NODE(dateYear);

	dateMonthYear = (
		month >> space  >> year
	)[qi::_val = phoenix::construct<Date>(qi::_2, qi::_1, 1)];
	BOOST_SPIRIT_DEBUG_NODE(dateMonthYear);

	dateDayMonth = (
		day >> space >> month
	)[qi::_val = phoenix::bind(&constructDayMonthDate, qi::_1, qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(dateDayMonth);

	date %= (
		relativeDate |
		dateYearMonthDay |
		dateYearMonth |
		dateMonthYear |
		dateDayMonth |
		dateYear
	);
	BOOST_SPIRIT_DEBUG_NODE(date);
	#pragma endregion

	relativeDate %= (
		ParserCharTraits::no_case[(
			qi::lit(L"next") |
			qi::lit(L"coming"))] >> space >>
		relativeDateInDirection(1) |

		ParserCharTraits::no_case[(
			qi::lit(L"this"))] >> space >>
		relativeDateInDirection(0) |

		ParserCharTraits::no_case[(
			qi::lit(L"last") |
			qi::lit(L"previous"))] >> space >>
		relativeDateInDirection(-1) |

		relativeDateInDays
	);
	relativeDate.name("relativeDate");

	relativeDateInDirection = ParserCharTraits::no_case[(
		(
			monthNames
			[qi::_val = phoenix::bind(&
				constructRelativeMonthDate, qi::_r1, qi::_1)] |

			weekDays
			[qi::_val = phoenix::bind(&
				constructRelativeWeekDayDate, qi::_r1, qi::_1)]
		)
	)];
	relativeDateInDirection.name("relativeDateInDirection");

	relativeDateInDays = (
		ParserCharTraits::no_case[qi::lit(L"today")][
			qi::_val = phoenix::bind(&constructRelativeDate, 0)
		] |

		ParserCharTraits::no_case[qi::lit(L"tomorrow")][
			qi::_val = phoenix::bind(&constructRelativeDate, 1)
		] |

		ParserCharTraits::no_case[qi::lit(L"yesterday")][
			qi::_val = phoenix::bind(&constructRelativeDate, -1)
		] |

		((qi::int_ >> space >> ParserCharTraits::no_case[qi::lit("days")])[
			qi::_val = phoenix::bind(&constructRelativeDate, qi::_1)
		]) |

		((qi::int_ >> space >> ParserCharTraits::no_case[qi::lit("weeks")])[
			qi::_val = phoenix::bind(&constructRelativeDate,
				qi::_1 * 7)
		])
	);
	relativeDateInDays.name("relativeDateInDays");
	#pragma endregion

	qi::on_error<qi::fail>(start,
		phoenix::bind(&onFailure, qi::_1, qi::_2, qi::_3, qi::_4));
}

void DateTimeParser::onFailure(
	ParserIteratorType /*begin*/,
	ParserIteratorType end,
	ParserIteratorType errorPos,
	const boost::spirit::info& message) {
	StringType lexeme(errorPos, end);
	throw ParseErrorException(message, lexeme);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\date_time_parser.cpp





	/**
	 * origin: .\You-NLP\date_time_parser.h
	 */

#pragma once
#ifndef YOU_NLP_DATE_TIME_PARSER_H_
#define YOU_NLP_DATE_TIME_PARSER_H_

#include <boost/date_time/gregorian/gregorian_types.hpp>
#include "parser.h"

namespace You {
namespace NLP {
namespace UnitTests { class DateTimeParserTests; }

/// The query parser that recognises our input syntax.
class DateTimeParser : public boost::spirit::qi::grammar<
	ParserIteratorType,
	boost::posix_time::ptime()> {
public:
	friend class UnitTests::DateTimeParserTests;

	/// The type of the iterator used in this grammar.
	typedef ParserIteratorType IteratorType;

	/// The type of the skipper used in this grammar.
	typedef ParserSkipperType SkipperType;

	/// The type of the lexeme buffer provided in a lexing semantic action.
	typedef std::vector<ParserCharEncoding::char_type> LexemeType;

	/// The type of input strings accepted by this parser.
	typedef std::basic_string<ParserCharEncoding::char_type> StringType;

public:
	DateTimeParser();

	/// Parses the given input string into a date.
	///
	/// \param[in] string The string to parse.
	/// \param[out] result The parsed date/time object.
	/// \return True if parsing was successful.
	static bool parse(
		const StringType& string,
		boost::posix_time::ptime& result);

	/// Parses the given input string into a date.
	///
	/// \param[in] string The string to parse.
	/// \return The date/time representing the string.
	/// \exception ParserException When parsing fails.
	static boost::posix_time::ptime parse(const StringType& string);

private:
	typedef int16_t Year;
	typedef int16_t Month;
	typedef int8_t Day;
	typedef boost::gregorian::date Date;
	typedef boost::posix_time::ptime DateTime;

	typedef boost::spirit::qi::rule<
		IteratorType,
		Date()> DateRule;

private:
	/// Parses a date into its boost::posix_time form.
	static DateTime buildDateTime(Date);

	/// Parses a partial date into its boost::date_time form.
	///
	/// The prototype is nasty because these are the kinds of dates that we
	/// support.
	static Date buildDate(Year, Month, Day);

	/// Parses the given year string into a full year. If this has only 2 digits
	/// then it will be treated as fuzzy; otherwise it will be a full year. This
	/// conversion will happen unless the year string is prefixed by a zero.
	///
	/// \param[in] chars The character string, containing ASCII 0-9.
	static Year parseFuzzyYear(
		const std::vector<ParserCharEncoding::char_type>& chars);

	/// Parses the given two-digit year into a full year according to system
	/// settings (on Windows) or using strptime conversion rules.
	///
	/// \param[in] year The year to convert. This must be between 0 and 99
	///                 inclusive.
	/// \return The actual year referenced.
	static Year parseTwoDigitYear(Year year);

	/// Constructs a date from the given day and month. This is the next day and
	/// month that will occur. If the month is before the current month, it will
	/// be the following year.
	///
	/// \return The date specified.
	static Date constructDayMonthDate(Day, Month);

	/// Constructs a relative date from a month.
	///
	/// \param[in] direction -1 for 'last', 0 for 'this', 1 for 'next'
	/// \param[in] month The month specified
	///
	/// \return The date specified.
	static Date constructRelativeMonthDate(int direction,
		boost::date_time::months_of_year month);

	/// Constructs a relative date from a week day.
	///
	/// \param[in] direction -1 for 'last', 0 for 'this', 1 for 'next'
	/// \param[in] month The day name specified
	///
	/// \return The date specified, relative to today.
	static Date constructRelativeWeekDayDate(int direction,
		boost::date_time::weekdays day);

	/// Constructs a relative date from today.
	///
	/// \param[in] daysFromToday The date to construct from today.
	///
	/// \return The date specified, relative to today.
	static Date constructRelativeDate(int daysFromToday);

	/// Handles failures in parsing. This raises a \ref ParseErrorException.
	///
	/// \exception ParseErrorException The exception representing the parse
	///                                error.
	static void onFailure(
		ParserIteratorType begin,
		ParserIteratorType end,
		ParserIteratorType errorPos,
		const boost::spirit::info& message);

private:
	/// The start rule.
	start_type start;

	/// Parsing dates.
	DateRule date;

	/// Rules to parse the various kinds of dates.
	/// @{
	DateRule dateYearMonthDay;
	DateRule dateYearMonth;
	DateRule dateYear;
	DateRule dateMonthYear;
	DateRule dateDayMonth;
	/// @}

	/// Rules to parse relative dates
	/// @{
	DateRule relativeDate;
	boost::spirit::qi::rule<
		IteratorType,
		Date(int)> relativeDateInDirection;  // NOLINT(readability/function)
	DateRule relativeDateInDays;
	/// @}

	/// Parsing years.
	boost::spirit::qi::rule<IteratorType, Year()> year;

	/// Parsing months.
	boost::spirit::qi::rule<IteratorType, Month()> month;

	/// List of months.
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		boost::gregorian::months_of_year> monthNames;

	/// List of day names
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		boost::date_time::weekdays> weekDays;

	/// Parsing days
	boost::spirit::qi::rule<IteratorType, Day()> day;

	/// A utility rule to handle whitespace.
	boost::spirit::qi::rule<IteratorType> space;
};

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_DATE_TIME_PARSER_H_

	// End of segment: .\You-NLP\date_time_parser.h





	/**
	 * origin: .\You-NLP\date_time_parser_actions.cpp
	 */

#include "stdafx.h"
#include <boost/lexical_cast.hpp>
#include <windows.h>

#include "exceptions/parser_exception.h"
#include "date_time_parser.h"

namespace You {
namespace NLP {

using ptime = boost::posix_time::ptime;
namespace qi = boost::spirit::qi;
namespace phoenix = boost::phoenix;

DateTimeParser::Year DateTimeParser::parseFuzzyYear(
	const std::vector<ParserCharEncoding::char_type>& chars) {
	Year value = boost::lexical_cast<Year>(
		StringType(chars.begin(), chars.end()));
	if (chars.size() == 2) {
		return parseTwoDigitYear(value);
	} else {
		return value;
	}
}

DateTimeParser::Year DateTimeParser::parseTwoDigitYear(Year year) {
	assert(year >= 0);
	assert(year <= 99);

#ifdef _WIN32
	auto getTwoDigitYearMax = []() throw() {
		static const wchar_t* TWO_DIGIT_YEAR_MAX_KEY =
			L"Control Panel\\International\\Calendars\\TwoDigitYearMax";

		HKEY twoDigitYearMaxKey;
		if (RegOpenKeyEx(
				HKEY_CURRENT_USER,
				TWO_DIGIT_YEAR_MAX_KEY,
				0,
				KEY_READ,
				&twoDigitYearMaxKey) == ERROR_SUCCESS
		) {
			DWORD twoDigitYearMax = 0;
			DWORD size = sizeof(twoDigitYearMax);

			DWORD result = RegQueryValueEx(
				twoDigitYearMaxKey,
				L"1",
				nullptr,
				nullptr,
				reinterpret_cast<BYTE*>(&twoDigitYearMax),
				&size);

			RegCloseKey(twoDigitYearMaxKey);
			if (result == ERROR_SUCCESS) {
				return twoDigitYearMax;
			}
		}

		return static_cast<DWORD>(2030);
	};  // NOLINT(readability/braces)

	Year twoDigitYearMax = static_cast<Year>(getTwoDigitYearMax());

	Year twoDigitCentury = twoDigitYearMax / 100;
	Year twoDigitModulus = twoDigitYearMax % 100;

	Year resultCentury = twoDigitCentury - ((year > twoDigitModulus) ? 1 : 0);
	return resultCentury * 100 + year;
#else
	if (year >= 69) {
		return 1900 + year;
	} else {
		return 2000 + year;
	}
#endif
}

DateTimeParser::Date DateTimeParser::constructDayMonthDate(
	Day day, Month month) {
	ptime now = boost::posix_time::second_clock::local_time();
	Date today = now.date();

	Date result = Date(today.year(), month, day);
	if (result < today) {
		result = Date(today.year() + 1, result.month(), result.day());
	}

	return result;
}

DateTimeParser::Date DateTimeParser::constructRelativeMonthDate(
	int direction,
	boost::date_time::months_of_year month) {
	boost::posix_time::ptime now =
		boost::posix_time::second_clock::local_time();
	Date today = now.date();

	assert(direction >= -1 && direction <= 1);
	if (direction == 0) {
		boost::gregorian::months difference(
			month - today.month());

		// Because boost::date_time doesn't have operator <=
		if (difference.number_of_months() < 0 ||
			difference.number_of_months() == 0) {
			difference = difference + boost::gregorian::years(1);
		}
		Date result(today + boost::gregorian::months(difference));
		return Date(result.year(), result.month(), 1);
	} else {
		return Date(today.year() + direction, month, 1);
	}
}

DateTimeParser::Date DateTimeParser::constructRelativeWeekDayDate(
	int direction,
	boost::date_time::weekdays day) {
	boost::posix_time::ptime now =
		boost::posix_time::second_clock::local_time();
	Date today = now.date();

	assert(direction >= -1 && direction <= 1);
	if (direction == 0) {
		boost::gregorian::days difference(
			static_cast<int>(day) - today.day_of_week());
		if (difference.days() <= 0) {
			difference = difference + boost::gregorian::weeks(1);
		}
		return today + difference;
	} else if (direction == 1) {
		return next_weekday(
			next_weekday(today, boost::gregorian::greg_weekday(
				boost::gregorian::Sunday)),
			boost::gregorian::greg_weekday(day));
	} else {
		return previous_weekday(
			previous_weekday(today, boost::gregorian::greg_weekday(
				boost::gregorian::Sunday)),
			boost::gregorian::greg_weekday(day));
	}
}

DateTimeParser::Date DateTimeParser::constructRelativeDate(int daysFromToday) {
	return boost::posix_time::second_clock::local_time().date() +
		boost::gregorian::days(daysFromToday);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\date_time_parser_actions.cpp





	/**
	 * origin: .\You-NLP\exception.h
	 */

#pragma once
#ifndef YOU_NLP_EXCEPTION_H_
#define YOU_NLP_EXCEPTION_H_

#include "exceptions/exception.h"
#include "exceptions/parser_exception.h"
#include "exceptions/parser_type_exception.h"
#include "exceptions/parse_error_exception.h"

#endif  // YOU_NLP_EXCEPTION_H_

	// End of segment: .\You-NLP\exception.h





	/**
	 * origin: .\You-NLP\exceptions\exception.h
	 */

#pragma once
#ifndef YOU_NLP_EXCEPTIONS_EXCEPTION_H_
#define YOU_NLP_EXCEPTIONS_EXCEPTION_H_

#include "You-Utils/exceptions/exception.h"

namespace You {
namespace NLP {

typedef You::Utils::Exception Exception;

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_EXCEPTIONS_EXCEPTION_H_

	// End of segment: .\You-NLP\exceptions\exception.h





	/**
	 * origin: .\You-NLP\exceptions\parser_exception.h
	 */

#pragma once
#ifndef YOU_NLP_EXCEPTIONS_PARSER_EXCEPTION_H_
#define YOU_NLP_EXCEPTIONS_PARSER_EXCEPTION_H_

#include "exception.h"

namespace You {
namespace NLP {

class ParserException : public Exception {
};

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_EXCEPTIONS_PARSER_EXCEPTION_H_

	// End of segment: .\You-NLP\exceptions\parser_exception.h





	/**
	 * origin: .\You-NLP\exceptions\parser_type_exception.h
	 */

#pragma once
#ifndef YOU_NLP_EXCEPTIONS_PARSER_TYPE_EXCEPTION_H_
#define YOU_NLP_EXCEPTIONS_PARSER_TYPE_EXCEPTION_H_

#include "parser_exception.h"

namespace You {
namespace NLP {

/// Represents a parser type mismatch in the NLP engine.
class ParserTypeException : public ParserException {
};

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_EXCEPTIONS_PARSER_TYPE_EXCEPTION_H_

	// End of segment: .\You-NLP\exceptions\parser_type_exception.h





	/**
	 * origin: .\You-NLP\exceptions\parse_error_exception.cpp
	 */

#include "stdafx.h"
#include "parse_error_exception.h"

namespace You {
namespace NLP {

namespace spirit = boost::spirit;

ParseErrorException::ParseErrorException(
	spirit::info message,
	std::wstring token)
: message(message),
  token(token) {
}

std::wstring ParseErrorException::getToken() {
	return token;
}
boost::spirit::info ParseErrorException::getMessage() {
	return message;
}
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\exceptions\parse_error_exception.cpp





	/**
	 * origin: .\You-NLP\exceptions\parse_error_exception.h
	 */

#pragma once
#ifndef YOU_NLP_EXCEPTIONS_PARSE_ERROR_EXCEPTION_H_
#define YOU_NLP_EXCEPTIONS_PARSE_ERROR_EXCEPTION_H_

#include "parser_exception.h"
#include <boost/spirit/include/support_info.hpp>

namespace You {
namespace NLP {

/// Represents a parse error in the NLP engine.
class ParseErrorException : public ParserException {
public:
	/// Constructor.
	///
	/// \param[in] message The Spirit parse error information.
	/// \param[in] token The token being parsed.
	ParseErrorException(
		boost::spirit::info message,
		std::wstring token);

	std::wstring getToken();

	boost::spirit::info getMessage();

private:
	/// The Spirit parse error.
	boost::spirit::info message;

	/// The token causing the error.
	std::wstring token;
};

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_EXCEPTIONS_PARSE_ERROR_EXCEPTION_H_

	// End of segment: .\You-NLP\exceptions\parse_error_exception.h





	/**
	 * origin: .\You-NLP\nlp.h
	 */

#pragma once
#ifndef YOU_NLP_NLP_H_
#define YOU_NLP_NLP_H_

#include "exception.h"
#include "parse_tree.h"
#include "date_time_parser.h"
#include "query_parser.h"

#endif  // YOU_NLP_NLP_H_

	// End of segment: .\You-NLP\nlp.h





	/**
	 * origin: .\You-NLP\parser.h
	 */

#pragma once
#ifndef YOU_NLP_PARSER_H_
#define YOU_NLP_PARSER_H_

#include <boost/spirit/include/qi.hpp>

namespace You {
namespace NLP {

/// Import the entire character traits namespace from Spirit.
namespace ParserCharTraits {
	// NOLINTNEXTLINE(build/namespaces)
	using namespace boost::spirit::qi::standard_wide;
}

/// The type of one character in the lexer stream.
typedef boost::spirit::char_encoding::standard_wide ParserCharEncoding;

/// The type of the parser iterator.
typedef std::wstring::const_iterator ParserIteratorType;

/// The type of the parser skipper.
typedef ParserCharTraits::space_type ParserSkipperType;

/// The type of expectation failure exceptions.
typedef boost::spirit::qi::expectation_failure<ParserIteratorType>
	ParserExpectationFailure;

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSER_H_

	// End of segment: .\You-NLP\parser.h





	/**
	 * origin: .\You-NLP\parser_logger.cpp
	 */

#include "stdafx.h"
#include "You-Utils/string_utils.h"
#include "parser_logger.h"

namespace You {
namespace NLP {

ParserLogger ParserLogger::log;

ParserLogger::ParserLogger() :
	std::wostream(&streamBuffer) {
}

ParserLogger& ParserLogger::operator<<(const std::string& string) {
	static_cast<std::wostream&>(*this) << string;
	return *this;
}

ParserLogger& ParserLogger::operator<<(
	std::wostream& (*manip)(std::wostream&)) {
	manip(*this);
	return *this;
}

int ParserLogger::LoggerStreamBuf::sync() {
	std::wstring buffer(str());
	str(std::wstring());

	// Remove trailing newlines.
	boost::trim_right(buffer);
	Utils::Log::debug << buffer;

	return 0;
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parser_logger.cpp





	/**
	 * origin: .\You-NLP\parser_logger.h
	 */

#pragma once
#ifndef YOU_NLP_PARSER_LOGGER_H_
#define YOU_NLP_PARSER_LOGGER_H_

#include "You-Utils/log.h"

namespace You {
namespace NLP {

class ParserLogger : public std::wostream {
public:
	ParserLogger();
	~ParserLogger() = default;

	/// The global parser logger.
	static ParserLogger log;

	template<typename TObject>
	ParserLogger& operator<<(TObject&& value) {
		*static_cast<std::wostream*>(this) <<
			boost::lexical_cast<std::wstring>(value);
		return *this;
	}

	/// Overload for writing strings. The names of rules are strings.
	ParserLogger& operator<<(const std::string& string);

	/// Compatibility with ostream manipulators. This is a no-op.
	ParserLogger& operator<<(std::wostream& (*manip)(std::wostream&));

private:
	class LoggerStreamBuf : public std::basic_stringbuf<wchar_t> {
	public:
		int sync() override;
	};

private:
	ParserLogger& operator=(const ParserLogger&) = delete;

private:
	/// The stream buffer holding the contents of the log message.
	LoggerStreamBuf streamBuffer;
};

}  // namespace NLP
}  // namespace You

namespace boost {
namespace spirit {
namespace qi {
namespace detail {

template<typename Char>
inline void token_printer(You::NLP::ParserLogger& m, Char c) {
	m << c;
}

}  // namespace detail
}  // namespace qi
}  // namespace spirit
}  // namespace boost

#include <boost/fusion/support/is_sequence.hpp>
namespace boost {
namespace fusion {

template<typename Sequence>
inline std::wostream&
	out(std::wostream& os, Sequence& seq) {
	detail::print_sequence(os, seq);
	return os;
}

namespace operators {

template <typename Sequence>
inline typename
	boost::enable_if<
		boost::fusion::traits::is_sequence<Sequence>,
		std::wostream&
	>::type
	operator<<(std::wostream& os, Sequence const& seq) {
	return fusion::out(os, seq);
}

}  // namespace operators
}  // namespace fusion
}  // namespace boost

#pragma endregion

#endif  // YOU_NLP_PARSER_LOGGER_H_

	// End of segment: .\You-NLP\parser_logger.h





	/**
	 * origin: .\You-NLP\parse_tree\add_query.cpp
	 */

#include "stdafx.h"
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>

#include "add_query.h"

namespace {

/// The format for displaying an ADD_QUERY
const boost::wformat STRING_FORMAT(L"%1% (start %2%, deadline %3%, "
	L"%4% priority, %5% subtasks, %6% dependents)");

}  // namespace

namespace You {
namespace NLP {

std::wostream& operator<<(std::wostream& s, const ADD_QUERY& q) {
	return s << (boost::wformat(STRING_FORMAT) % q.description % (
		q.start ?
			boost::lexical_cast<std::wstring>(q.start.get()) : L"none"
	) % (
		q.deadline ?
			boost::lexical_cast<std::wstring>(q.deadline.get()) : L"none"
	) % (
		q.priority == TaskPriority::HIGH ? L"high" : L"normal"
	) % (
		q.subtasks.size()
	) % (
		q.dependent ? 1 : 0
	));
}

bool ADD_QUERY::operator==(const ADD_QUERY& rhs) const {
	return description == rhs.description &&
		priority == rhs.priority &&
		start == rhs.start &&
		deadline == rhs.deadline &&
		subtasks.size() == rhs.subtasks.size() &&
		std::equal(begin(subtasks), end(subtasks), begin(rhs.subtasks)) &&
		(
			(!dependent && !rhs.dependent) || (
				dependent && rhs.dependent &&
					*dependent.get() == *rhs.dependent.get()));
}

std::wstring ToString(const ADD_QUERY& q) {
	return boost::lexical_cast<std::wstring>(q);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\add_query.cpp





	/**
	 * origin: .\You-NLP\parse_tree\add_query.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_ADD_QUERY_H_
#define YOU_NLP_PARSE_TREE_ADD_QUERY_H_

#include <string>
#include <boost/date_time/posix_time/posix_time.hpp>

#include "You-Utils/option.h"
#include "task_priority.h"

namespace You {
namespace NLP {

/// Defines the synthesised value type of an add query.
struct ADD_QUERY {
	/// Equality comparator.
	///
	/// \param[in] rhs The other query object to compare with.
	bool operator==(const ADD_QUERY& rhs) const;

	/// The description of the task.
	std::wstring description;

	/// The priority of the task.
	TaskPriority priority;

	/// The start time of the task.
	You::Utils::Option<boost::posix_time::ptime> start;

	/// The deadline of the task.
	You::Utils::Option<boost::posix_time::ptime> deadline;

	/// The subtasks of the task.
	std::vector<ADD_QUERY> subtasks;

	/// The dependent of this task.
	std::shared_ptr<ADD_QUERY> dependent;
};

/// Defines an output formatter for ADD_QUERY queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] q The query to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const ADD_QUERY& q);

/// String conversion -- mainly useful for unit testing and display.
///
/// \param[in] q The query to convert to a string.
/// \return The string representation of the current query object.
std::wstring ToString(const ADD_QUERY& q);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_ADD_QUERY_H_

	// End of segment: .\You-NLP\parse_tree\add_query.h





	/**
	 * origin: .\You-NLP\parse_tree\delete_query.cpp
	 */

#include "stdafx.h"
#include "delete_query.h"

namespace {

/// The format for displaying an DELETE_QUERY.
const boost::wformat STRING_FORMAT(L"Delete task #%1%");

}  // namespace

namespace You {
namespace NLP {

std::wostream& operator<<(std::wostream& s, const DELETE_QUERY& q) {
	return s << boost::wformat(STRING_FORMAT) % q.taskID;
}

bool DELETE_QUERY::operator==(const DELETE_QUERY& rhs) const {
	return taskID == rhs.taskID;
}

std::wstring ToString(const DELETE_QUERY& q) {
	return boost::lexical_cast<std::wstring>(q);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\delete_query.cpp





	/**
	 * origin: .\You-NLP\parse_tree\delete_query.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_DELETE_QUERY_H_
#define YOU_NLP_PARSE_TREE_DELETE_QUERY_H_

namespace You {
namespace NLP {

/// Defines the synthesised value type of a delete query.
struct DELETE_QUERY {
	/// Equality comparator.
	///
	/// \param[in] rhs The other query object to compare with.
	bool operator==(const DELETE_QUERY& rhs) const;

	/// The task offset which should be changed
	size_t taskID;
};

/// Defines an output formatter for DELETE_QUERY queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] q The query to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const DELETE_QUERY& q);

/// String conversion -- mainly useful for unit testing and display.
///
/// \param[in] q The query to convert to a string.
/// \return The string representation of the current query object.
std::wstring ToString(const DELETE_QUERY& q);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_DELETE_QUERY_H_

	// End of segment: .\You-NLP\parse_tree\delete_query.h





	/**
	 * origin: .\You-NLP\parse_tree\edit_query.cpp
	 */

#include "stdafx.h"
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "task_field.h"
#include "edit_query.h"

using You::NLP::EDIT_QUERY;

namespace You {
namespace NLP {
namespace {

/// The format for displaying an EDIT_QUERY.
const boost::wformat STRING_FORMAT(L"Edit task #%1% (%2%)");

/// The format for displaying a field change.
const boost::wformat CHANGE_FIELD_FORMAT(L"%1% => %2%");

/// Converts the attachment actions to a string.
std::vector<std::wstring> getAttachmentActionsAsString(
	const std::vector<EDIT_QUERY::ATTACHMENT_ACTION>& q) {
	std::vector<std::wstring> result;
	std::transform(begin(q), end(q), std::back_inserter(result),
		[](const EDIT_QUERY::ATTACHMENT_ACTION& a) {
			return boost::lexical_cast<std::wstring>(a);
		});

	return result;
}

/// Converts the changed fields to a string.
std::vector<std::wstring> getChangedFieldsAsString(const EDIT_QUERY& q) {
	using You::NLP::TaskField;

	std::vector<std::wstring> fields;
	if (q.description) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::DESCRIPTION %
			q.description.get()).str());
	}

	if (q.priority) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::PRIORITY %
			q.priority.get()).str());
	}

	if (q.start) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::START %
			q.start.get()).str());
	}

	if (q.deadline) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::DEADLINE %
			q.deadline.get()).str());
	}

	if (q.complete) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::COMPLETE %
			q.complete.get()).str());
	}

	if (q.childTask) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::SUBTASKS %
			q.childTask.get()).str());
	}

	if (q.dependingTask) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::DEPENDENTS %
			q.dependingTask.get()).str());
	}

	if (!q.attachments.empty()) {
		fields.emplace_back(
			(boost::wformat(CHANGE_FIELD_FORMAT) %
			TaskField::ATTACHMENTS %
			boost::algorithm::join(getAttachmentActionsAsString(q.attachments),
				L", ")).str());
	}
	return fields;
}

}  // namespace

std::wostream& operator<<(std::wostream& s, const EDIT_QUERY& q) {
	return s << boost::wformat(STRING_FORMAT) % q.taskID %
		boost::algorithm::join(getChangedFieldsAsString(q), L", ");
}

std::wostream& operator<<(std::wostream& s,
	const EDIT_QUERY::ATTACHMENT_ACTION& a) {
	return s <<
		(a.add ? L"add" : L"remove") << L' ' <<
		a.path;
}

bool EDIT_QUERY::operator==(const EDIT_QUERY& rhs) const {
	if (taskID != rhs.taskID) {
		return false;
	}

	return description == rhs.description &&
		priority == rhs.priority &&
		start == rhs.start &&
		deadline == rhs.deadline &&
		complete == rhs.complete &&
		childTask == rhs.childTask &&
		dependingTask == rhs.dependingTask &&
		attachments.size() == rhs.attachments.size() &&
		std::equal(
			begin(attachments),
			end(attachments),
			begin(rhs.attachments));
}

bool EDIT_QUERY::ATTACHMENT_ACTION::operator==(
	const ATTACHMENT_ACTION& rhs) const {
	return add == rhs.add &&
		path == rhs.path;
}

std::wstring ToString(const EDIT_QUERY& q) {
	return boost::lexical_cast<std::wstring>(q);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\edit_query.cpp





	/**
	 * origin: .\You-NLP\parse_tree\edit_query.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_EDIT_QUERY_H_
#define YOU_NLP_PARSE_TREE_EDIT_QUERY_H_

#include <string>
#include <boost/date_time/posix_time/posix_time.hpp>

#include "You-Utils/option.h"
#include "task_priority.h"
#include "task_field.h"

namespace You {
namespace NLP {

/// Defines the synthesised value type of an edit query.
struct EDIT_QUERY {
	/// The action to do for the specified attachment.
	struct ATTACHMENT_ACTION {
		/// Equality comparator.
		///
		/// \param[in] rhs The other action object to compare with.
		bool operator==(const ATTACHMENT_ACTION& rhs) const;

		/// Whether to add the attachment.
		bool add;

		/// The path to the attachment.
		std::wstring path;
	};

	/// Equality comparator.
	///
	/// \param[in] rhs The other query object to compare with.
	bool operator==(const EDIT_QUERY& rhs) const;

	/// The task offset which should be changed
	size_t taskID;

	/// The description of the task.
	You::Utils::Option<std::wstring> description;

	/// The priority of the task.
	You::Utils::Option<TaskPriority> priority;

	/// The start time of the task
	You::Utils::Option<boost::posix_time::ptime> start;

	/// The deadline of the task.
	You::Utils::Option<boost::posix_time::ptime> deadline;

	/// Whether the task is complete
	You::Utils::Option<bool> complete;

	/// The task to set as a subtask of the \ref taskID
	You::Utils::Option<int> childTask;

	/// The task to set as a depending on \ref taskID
	You::Utils::Option<int> dependingTask;

	/// The attachments to add and remove.
	std::vector<ATTACHMENT_ACTION> attachments;
};

/// Defines an output formatter for EDIT_QUERY attachment queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] a The action to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s,
	const EDIT_QUERY::ATTACHMENT_ACTION& a);

/// Defines an output formatter for EDIT_QUERY queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] q The query to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const EDIT_QUERY& q);

/// String conversion -- mainly useful for unit testing and display.
///
/// \param[in] q The query to convert to a string.
/// \return The string representation of the current query object.
std::wstring ToString(const EDIT_QUERY& q);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_EDIT_QUERY_H_

	// End of segment: .\You-NLP\parse_tree\edit_query.h





	/**
	 * origin: .\You-NLP\parse_tree\show_query.cpp
	 */

#include "stdafx.h"
#include <boost/format.hpp>
#include <boost/algorithm/string.hpp>

#include "You-Utils/fatal.h"
#include "show_query.h"

namespace You {
namespace NLP {
namespace {

/// The format for displaying an SHOW_QUERY
const boost::wformat STRING_FORMAT(L"Show tasks (criteria %1%, sort by %2%)");

/// The format for displaying a field change.
const boost::wformat FILTER_FIELD_FORMAT(L"%1%%2%%3%");

/// The format for displaying a field ordering.
const boost::wformat SORT_FIELD_FORMAT(L"%1% %2%");

/// Joins items together
const std::wstring LIST_JOIN_SEPARATOR(L", ");

/// None message
const std::wstring NONE_MESSAGE(L"none");

/// Sorted ascending
const std::wstring ASCENDING_ORDER_MESSAGE(L"ascending");

/// Sorted descending
const std::wstring DESCENDING_ORDER_MESSAGE(L"descending");

/// Gets the predicate fields as a string.
std::wstring getPredicateFieldsAsString(const You::NLP::SHOW_QUERY& q) {
	std::vector<std::wstring> predicateStrings;
	predicateStrings.reserve(q.predicates.size());

	std::transform(begin(q.predicates), end(q.predicates),
		std::back_inserter(predicateStrings),
		[](const You::NLP::SHOW_QUERY::FIELD_FILTER& filter) {
		return boost::lexical_cast<std::wstring>(filter);
	});

	if (predicateStrings.empty()) {
		return NONE_MESSAGE;
	} else {
		return boost::algorithm::join(predicateStrings, LIST_JOIN_SEPARATOR);
	}
}

/// Gets the sorting fields as a string.
std::wstring getSortFieldsAsString(const You::NLP::SHOW_QUERY& q) {
	std::vector<std::wstring> orderStrings;
	orderStrings.reserve(q.order.size());

	std::transform(begin(q.order), end(q.order),
		std::back_inserter(orderStrings),
		[](const You::NLP::SHOW_QUERY::FIELD_ORDER& order) {
			return boost::lexical_cast<std::wstring>(order);
		});

	if (orderStrings.empty()) {
		return NONE_MESSAGE;
	} else {
		return boost::algorithm::join(orderStrings, LIST_JOIN_SEPARATOR);
	}
}

}  // namespace

std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::Predicate& p) {
	const wchar_t* string = nullptr;
	switch (p) {
	case SHOW_QUERY::Predicate::EQ:
		string = L"=";
		break;
	case SHOW_QUERY::Predicate::SIMILAR:
		string = L"~";
		break;
	case SHOW_QUERY::Predicate::NOT_EQ:
		string = L"!=";
		break;
	case SHOW_QUERY::Predicate::GREATER_THAN:
		string = L">";
		break;
	case SHOW_QUERY::Predicate::GREATER_THAN_EQ:
		string = L">=";
		break;
	case SHOW_QUERY::Predicate::LESS_THAN:
		string = L"<";
		break;
	case SHOW_QUERY::Predicate::LESS_THAN_EQ:
		string = L"<=";
		break;
	default:
		fatal();
	}

	return s << string;
}

std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::FIELD_FILTER& f) {
	return s << (boost::wformat(FILTER_FIELD_FORMAT) %
		f.field %
		f.predicate %
		f.value).str();
}
std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::FIELD_ORDER& o) {
	return s << (boost::wformat(SORT_FIELD_FORMAT) %
		o.field %
		(o.order == You::NLP::SHOW_QUERY::Order::ASCENDING ?
			ASCENDING_ORDER_MESSAGE : DESCENDING_ORDER_MESSAGE)).str();
}

std::wostream& operator<<(std::wostream& s, const SHOW_QUERY& q) {
	return s << (boost::wformat(STRING_FORMAT) %
		getPredicateFieldsAsString(q) %
		getSortFieldsAsString(q));
}

bool SHOW_QUERY::FIELD_FILTER::operator==(const FIELD_FILTER& rhs) const {
	return field == rhs.field &&
		predicate == rhs.predicate &&
		value == rhs.value;
}

bool SHOW_QUERY::FIELD_ORDER::operator==(const FIELD_ORDER& rhs) const {
	return field == rhs.field &&
		order == rhs.order;
}

bool SHOW_QUERY::operator==(const SHOW_QUERY& rhs) const {
	return predicates.size() == rhs.predicates.size() &&
		std::equal(begin(predicates), end(predicates), begin(rhs.predicates)) &&
		order.size() == rhs.order.size() &&
		std::equal(begin(order), end(order), begin(rhs.order));
}

std::wstring ToString(const SHOW_QUERY& q) {
	return boost::lexical_cast<std::wstring>(q);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\show_query.cpp





	/**
	 * origin: .\You-NLP\parse_tree\show_query.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_SHOW_QUERY_H_
#define YOU_NLP_PARSE_TREE_SHOW_QUERY_H_

#include <string>
#include <vector>

#include "You-Utils/option.h"
#include "task_field.h"
#include "task_priority.h"

namespace You {
namespace NLP {

/// Defines the synthesised value type of show query.
struct SHOW_QUERY {
	/// The order in which columns are sorted
	enum class Order {
		/// The column will be sorted in an ascending order.
		ASCENDING = 0,

		/// The column will be sorted in a descending order.
		DESCENDING
	};

	/// The predicate for filtering tasks.
	enum class Predicate {
		/// Equality.
		EQ,

		/// Similarity.
		SIMILAR,

		/// Inequality
		NOT_EQ,

		/// Less than
		LESS_THAN,

		/// Less than or equal
		LESS_THAN_EQ,

		/// Greater than
		GREATER_THAN,

		/// Greater than or equal
		GREATER_THAN_EQ
	};

	/// A predicate for filtering tasks.
	struct FIELD_FILTER {
		/// Equality comparator.
		///
		/// \param[in] rhs The other field order object to compare with.
		bool operator==(const FIELD_FILTER& rhs) const;

		/// The field to filter.
		TaskField field;

		/// The predicate to apply.
		Predicate predicate;

		/// The value to compare against.
		boost::variant<
			std::wstring,
			TaskPriority,
			boost::posix_time::ptime,
			bool> value;
	};

	/// A pair containing the field and the order to sort by.
	struct FIELD_ORDER {
		/// Equality comparator.
		///
		/// \param[in] rhs The other field order object to compare with.
		bool operator==(const FIELD_ORDER& rhs) const;

		/// The field to sort.
		TaskField field;

		/// The order to sort the field by.
		Order order;
	};

	/// Equality comparator.
	///
	/// \param[in] rhs The other query object to compare with.
	bool operator==(const SHOW_QUERY& rhs) const;

	/// The predicates for filtering.
	std::vector<FIELD_FILTER> predicates;

	/// The order of the fields.
	std::vector<FIELD_ORDER> order;
};

/// Defines an output formatter for SHOW_QUERY predicates.
///
/// \param[in,out] s The stream to write to.
/// \param[in] p The predicate to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::Predicate& p);

/// Defines an output formatter for SHOW_QUERY filters.
///
/// \param[in,out] s The stream to write to.
/// \param[in] f The field filter to display
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::FIELD_FILTER& f);

/// Defines an output formatter for SHOW_QUERY sorting orders.
///
/// \param[in,out] s The stream to write to.
/// \param[in] o The field order to display
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const SHOW_QUERY::FIELD_ORDER& o);

/// Defines an output formatter for SHOW_QUERY queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] q The query to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const SHOW_QUERY& q);

/// String conversion -- mainly useful for unit testing and display.
///
/// \param[in] q The query to convert to a string.
/// \return The string representation of the current query object.
std::wstring ToString(const SHOW_QUERY& q);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_SHOW_QUERY_H_

	// End of segment: .\You-NLP\parse_tree\show_query.h





	/**
	 * origin: .\You-NLP\parse_tree\task_field.cpp
	 */

#include "stdafx.h"

#include "task_field.h"

namespace {

/// The description field.
const std::wstring DESCRIPTION_FIELD(L"Description");

/// The priority field.
const std::wstring PRIORITY_FIELD(L"Priority");

/// The start field.
const std::wstring START_FIELD(L"Start");

/// The deadline field.
const std::wstring DEADLINE_FIELD(L"Deadline");

/// The completion field.
const std::wstring COMPLETE_FIELD(L"Complete");

/// The subtasks field.
const std::wstring SUBTASKS_FIELD(L"Subtasks");

/// The dependents of this task.
const std::wstring DEPENDENTS_FIELDS(L"Depending");

/// The attachments field.
const std::wstring ATTACHMENTS_FIELD(L"Attachments");

}  // namespace

namespace You {
namespace NLP {

TaskField operator|(const TaskField& lhs, const TaskField& rhs) {
	return static_cast<TaskField>(
		static_cast<size_t>(lhs) | static_cast<size_t>(rhs)
	);
}

TaskField operator&(const TaskField& lhs, const TaskField& rhs) {
	return static_cast<TaskField>(
		static_cast<size_t>(lhs)& static_cast<size_t>(rhs)
	);
}

std::wostream& operator<<(std::wostream& stream, TaskField priority) {
	return stream << ToString(priority);
}

/// Converts the sorting fields to strings.
std::wstring ToString(const TaskField& field) {
	using TaskField = You::NLP::TaskField;
	switch (field) {
	case TaskField::DESCRIPTION:
		return DESCRIPTION_FIELD;
	case TaskField::PRIORITY:
		return PRIORITY_FIELD;
	case TaskField::START:
		return START_FIELD;
	case TaskField::DEADLINE:
		return DEADLINE_FIELD;
	case TaskField::COMPLETE:
		return COMPLETE_FIELD;
	case TaskField::SUBTASKS:
		return SUBTASKS_FIELD;
	case TaskField::DEPENDENTS:
		return DEPENDENTS_FIELDS;
	case TaskField::ATTACHMENTS:
		return ATTACHMENTS_FIELD;
	case TaskField::NONE:
	default:
		return std::wstring();
	}
}


}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\task_field.cpp





	/**
	 * origin: .\You-NLP\parse_tree\task_field.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_TASK_FIELD_H_
#define YOU_NLP_PARSE_TREE_TASK_FIELD_H_

#include <iosfwd>

namespace You {
namespace NLP {

/// The possible fields for tasks.
enum class TaskField {
	/// Not changing anything.
	NONE = 0,

	/// The description field needs to be changed
	DESCRIPTION = 1 << 0,

	/// The priority of the task
	PRIORITY = 1 << 1,

	/// The start field of the task
	START = 1 << 2,

	/// The deadline field
	DEADLINE = 1 << 3,

	/// The task is now complete
	COMPLETE = 1 << 4,

	/// The subtasks of this task.
	SUBTASKS = 1 << 5,

	/// The dependents of this task.
	DEPENDENTS = 1 << 6,

	/// The attachments need to be updated
	ATTACHMENTS = 1 << 7
};

/// Formats the given task priority to stream.
///
/// \param[in] stream The stream to write to.
/// \param[in] priority The priority to display.
/// \return The stream given.
std::wostream& operator<<(std::wostream& stream, TaskField priority);

/// Converts the given TaskField to a string.
///
/// \param[in] field The field to convert.
std::wstring ToString(const TaskField& field);

/// Computes a bitwise OR over the two fields specification flags.
///
/// \param[in] lhs The left hand side of the expression.
/// \param[in] rhs The right hand side of the expression.
/// \return The combined fields from both fields.
TaskField operator|(const TaskField& lhs, const TaskField& rhs);

/// Computes a bitwise AND over the two fields specification flags.
///
/// \param[in] lhs The left hand side of the expression.
/// \param[in] rhs The right hand side of the expression.
/// \return The common fields from both fields.
TaskField operator&(const TaskField& lhs, const TaskField& rhs);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_TASK_FIELD_H_

	// End of segment: .\You-NLP\parse_tree\task_field.h





	/**
	 * origin: .\You-NLP\parse_tree\task_priority.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_TASK_PRIORITY_H_
#define YOU_NLP_PARSE_TREE_TASK_PRIORITY_H_

namespace You {
namespace NLP {

/// The possible priorities for tasks.
enum class TaskPriority {
	/// Normal task priority
	NORMAL = 0,

	/// High task priority
	HIGH
};

/// Formats the given task priority to stream.
///
/// \param[in] stream The stream to write to.
/// \param[in] priority The priority to display.
/// \return The stream given.
inline std::wostream& operator<<(std::wostream& stream, TaskPriority priority) {
	return stream << static_cast<int>(priority);
}

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_TASK_PRIORITY_H_

	// End of segment: .\You-NLP\parse_tree\task_priority.h





	/**
	 * origin: .\You-NLP\parse_tree\undo_query.cpp
	 */

#include "stdafx.h"
#include <boost/lexical_cast.hpp>

#include "undo_query.h"

namespace {

/// The format for displaying an UNDO_QUERY
const std::wstring STRING_FORMAT(L"undo");

}  // namespace

namespace You {
namespace NLP {

std::wostream& operator<<(std::wostream& s, const UNDO_QUERY& /*q*/) {
	return s << STRING_FORMAT;
}

bool UNDO_QUERY::operator==(const UNDO_QUERY& /*rhs*/) const {
	// All undo queries are the same!
	return true;
}

std::wstring ToString(const UNDO_QUERY& q) {
	return boost::lexical_cast<std::wstring>(q);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\parse_tree\undo_query.cpp





	/**
	 * origin: .\You-NLP\parse_tree\undo_query.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_UNDO_QUERY_H_
#define YOU_NLP_PARSE_TREE_UNDO_QUERY_H_

#include <iosfwd>
#include <string>

namespace You {
namespace NLP {

/// Defines the synthesised value type of an undo query.
struct UNDO_QUERY {
	/// Equality comparator.
	///
	/// \param[in] rhs The other query object to compare with.
	bool operator==(const UNDO_QUERY& rhs) const;
};

/// Defines an output formatter for UNDO_QUERY queries.
///
/// \param[in,out] s The stream to write to.
/// \param[in] q The query to display.
/// \return The stream object passed to the formatter.
std::wostream& operator<<(std::wostream& s, const UNDO_QUERY& q);

/// String conversion -- mainly useful for unit testing and display.
///
/// \param[in] q The query to convert to a string.
/// \return The string representation of the current query object.
std::wstring ToString(const UNDO_QUERY& q);

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_UNDO_QUERY_H_

	// End of segment: .\You-NLP\parse_tree\undo_query.h





	/**
	 * origin: .\You-NLP\parse_tree.h
	 */

#pragma once
#ifndef YOU_NLP_PARSE_TREE_H_
#define YOU_NLP_PARSE_TREE_H_

#include <boost/variant.hpp>

#include "parse_tree/add_query.h"
#include "parse_tree/show_query.h"
#include "parse_tree/edit_query.h"
#include "parse_tree/delete_query.h"
#include "parse_tree/undo_query.h"
#include "parse_tree/task_priority.h"

namespace You {
namespace NLP {

/// Defines the synthesised value type of a query.
typedef boost::variant<
	ADD_QUERY,
	SHOW_QUERY,
	EDIT_QUERY,
	DELETE_QUERY,
	UNDO_QUERY
> QUERY;

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_PARSE_TREE_H_

	// End of segment: .\You-NLP\parse_tree.h





	/**
	 * origin: .\You-NLP\query_parser.cpp
	 */

#include "stdafx.h"
#include "exceptions/parse_error_exception.h"
#include "query_parser.h"

namespace You {
namespace NLP {

namespace spirit = boost::spirit;
namespace qi = spirit::qi;
namespace phoenix = boost::phoenix;

QUERY QueryParser::parse(const StringType& string) {
	QUERY result;

	if (parse(string, result)) {
		return result;
	} else {
		throw ParserException();
	}
}

bool QueryParser::parse(const StringType& string, QUERY& result) {
	try {
		return qi::parse(
			begin(string),
			end(string),
			QueryParser() > qi::omit[*ParserCharTraits::blank] > qi::eoi,
			result);
	} catch (ParserExpectationFailure&) {
		return false;
	}
}

QueryParser::QueryParser() : QueryParser::base_type(start) {
	start %= (
		(qi::lit('/') > explicitCommand) |
		addCommand
	);
	BOOST_SPIRIT_DEBUG_NODE(start);

	explicitCommand %= (
		(qi::lit("add") > space > addCommand) |
		((qi::lit("show") | qi::lit("find")) > *space > showCommand) |
		(qi::lit("edit") > space > editCommand) |
		(qi::lit("delete") > space > deleteCommand) |
		(qi::lit("undo") > *space > undoCommand)
	);
	BOOST_SPIRIT_DEBUG_NODE(explicitCommand);

	#pragma region Adding tasks
	addCommand = (
		addCommandDescription >
		-(*space >> qi::lit("->") > *space > addCommand) >
		-(*space >> qi::lit(':') > *space > addCommandSubtasks)
	)[qi::_val = phoenix::bind(
		&constructAddQuery,
		qi::_1,
		qi::_2,
		qi::_3)];
	BOOST_SPIRIT_DEBUG_NODE(addCommand);

	addCommandDescription %= (
		addCommandDescriptionQuoted |
		addCommandDescriptionUnquoted
	);
	BOOST_SPIRIT_DEBUG_NODE(addCommandDescription);

	addCommandDescriptionQuoted = (
		string > addCommandPriority
	)[qi::_val = phoenix::bind(
		static_cast<ADD_QUERY (*)(StringType, ADD_QUERY)>(
			&constructAddQueryFromDescription),
		qi::_1,
		qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(addCommandDescriptionQuoted);

	addCommandDescriptionUnquoted = (
		ParserCharTraits::char_ > addCommandDescriptionUnquotedTail
	)[qi::_val = phoenix::bind(
		static_cast<ADD_QUERY(*)(ParserCharEncoding::char_type, ADD_QUERY)>(
			&constructAddQueryFromDescription),
		qi::_1,
		qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(addCommandDescriptionUnquoted);

	addCommandDescriptionUnquotedTail %= (
		addCommandPriority |
		addCommandDescriptionUnquoted
	);
	BOOST_SPIRIT_DEBUG_NODE(addCommandDescriptionUnquotedTail);

	addCommandPriority %= (
		(*space >> qi::lit('!') >> addCommandTimeOptional)
			[qi::_val = phoenix::bind(&constructAddQueryWithPriority, qi::_1)] |
			addCommandTimeOptional
	);
	BOOST_SPIRIT_DEBUG_NODE(addCommandPriority);

	addCommandTime = (
#ifdef _DEBUG
		((addCommandTimeFrom || addCommandTimeTo)
		[qi::_val = phoenix::bind(&constructAddQueryWithTime, qi::_1, qi::_2)])
#else
		// Equivalent code for release builds. VC++ generates the wrong program
		// with optimisations.
		((addCommandTimeFrom >> -addCommandTimeTo)
		[qi::_val = phoenix::bind(&constructAddQueryWithTime,
			qi::_1,
			qi::_2)]) |
		((addCommandTimeTo)
		[qi::_val = phoenix::bind(&constructAddQueryWithTime,
			boost::none,
			qi::_1)])
#endif
		>> *space
	);
	BOOST_SPIRIT_DEBUG_NODE(addCommandTime);

	addCommandTimeFrom %= (
		space >> (qi::lit("from") | qi::lit("after")) >> space >> time);
	addCommandTimeTo %= (
		(space >> (qi::lit("by") | qi::lit("before") | qi::lit("to")) >>
			space >> time));

	addCommandTimeOptional = (
		addCommandTime || (
			*space >> &(qi::char_(":;") | qi::lit("->") | qi::eoi))
	)[qi::_val = phoenix::bind(&constructAddQueryWithOptionalTime, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(addCommandTimeOptional);

	addCommandSubtasks %= (
		addCommand % (*space >> qi::lit(';') >> *space)
	);
	BOOST_SPIRIT_DEBUG_NODE(addCommandSubtasks);
	#pragma endregion

	#pragma region Showing tasks
	showCommand = (
		-showCommandFiltering >
		-(-space >> (qi::lit("sorted by") | qi::lit("order by")) > space >
		showCommandSorting)
	)[qi::_val = phoenix::bind(&constructShowQuery, qi::_1, qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(showCommand);

	showCommandFiltering %=
		showCommandFilteringColumn % (
			(-space >> qi::lit(',') >> -space) |
			(space >> qi::lit("and") >> space));
	BOOST_SPIRIT_DEBUG_NODE(showCommandFiltering);

	showCommandFilteringColumn = (
		showCommandFields >
		-space > showCommandFilteringPredicate > -space >
		value
	)[qi::_val = phoenix::bind(&constructShowQueryFilteringColumn,
		qi::_1,
		qi::_2,
		qi::_3)];
	BOOST_SPIRIT_DEBUG_NODE(showCommandFiltering);

	showCommandFilteringPredicate.add
		(L"=", SHOW_QUERY::Predicate::EQ)
		(L"~", SHOW_QUERY::Predicate::SIMILAR)
		(L"!=", SHOW_QUERY::Predicate::NOT_EQ)
		(L"<", SHOW_QUERY::Predicate::LESS_THAN)
		(L"<=", SHOW_QUERY::Predicate::LESS_THAN_EQ)
		(L">", SHOW_QUERY::Predicate::GREATER_THAN)
		(L">=", SHOW_QUERY::Predicate::GREATER_THAN_EQ);

	showCommandSorting %= (
		showCommandSortingColumn % (
			(-space >> qi::lit(",") >> -space) |
			(space >> qi::lit("then") >> space)));
	BOOST_SPIRIT_DEBUG_NODE(showCommandSorting);

	showCommandSortingColumn = (
		showCommandFields >> -(space >> showCommandSortingOrders)
	)[qi::_val = phoenix::bind(&constructShowQuerySortColumn, qi::_1, qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(showCommandSortingColumn);

	showCommandSortingOrders.add
		(L"asc", SHOW_QUERY::Order::ASCENDING)
		(L"ascending", SHOW_QUERY::Order::ASCENDING)
		(L"desc", SHOW_QUERY::Order::DESCENDING)
		(L"descending", SHOW_QUERY::Order::DESCENDING);

	showCommandFields.add
		(L"description", TaskField::DESCRIPTION)
		(L"start", TaskField::START)
		(L"deadline", TaskField::DEADLINE)
		(L"priority", TaskField::PRIORITY)
		(L"done", TaskField::COMPLETE)
		(L"complete", TaskField::COMPLETE)
		(L"completed", TaskField::COMPLETE);
	#pragma endregion

	#pragma region Editing tasks
	editCommand = (
		qi::uint_ > (
			(space >> qi::lit("set") > space > editCommandRule) |
			(*space >> qi::lit("!") > editSetHighPriority) |
			(editSetTimes) |
			(*space >> qi::lit(":") > *space > editSetSubtask) |
			(*space >> qi::lit("->") > *space > editSetDependent) |
			(space >> qi::lit("attach") > space >
				editAttachmentCommandRule(true)) |
			(space >> qi::lit("detach") > space >
				editAttachmentCommandRule(false)))
	)[qi::_val = phoenix::bind(&constructEditQuery,
		qi::_1, qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(editCommand);

	editCommandRule %= (
		editCommandRuleNullary |
		editCommandRuleUnary |
		editCommandRulePriorities
	);
	BOOST_SPIRIT_DEBUG_NODE(editCommandRule);

	editCommandRuleNullary = (
		editCommandFieldsNullary
	)[qi::_val = phoenix::bind(&constructEditQueryNullary, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(editCommandRuleNullary);

	editCommandRuleUnary = (
		editCommandFieldsUnary >
		*space > qi::lit('=') > *space >
		value)
	[qi::_val = phoenix::bind(&constructEditQueryUnary, qi::_1, qi::_2)];
	BOOST_SPIRIT_DEBUG_NODE(editCommandRuleUnary);

	editCommandRulePriorities = (
		qi::lit("priority") >
		*space > qi::lit('=') > *space >
		taskPriority
	)[qi::_val = phoenix::bind(&constructEditQueryPriority, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(editCommandRulePriorities);

	editCommandFieldsUnary.add
		(L"description", TaskField::DESCRIPTION)
		(L"start", TaskField::START)
		(L"deadline", TaskField::DEADLINE);

	editCommandFieldsNullary.add
		(L"done", TaskField::COMPLETE)
		(L"complete", TaskField::COMPLETE)
		(L"completed", TaskField::COMPLETE);

	editSetHighPriority = (
		qi::eps
	)[qi::_val = phoenix::bind(&constructEditQueryPriority,
		TaskPriority::HIGH)];
	BOOST_SPIRIT_DEBUG_NODE(editSetHighPriority);

	editSetTimes = (
#ifdef _DEBUG
		(editSetTimesFrom || editSetTimesTo)
		[qi::_val = phoenix::bind(&constructEditQueryTimes,
			qi::_1, qi::_2)]
#else
		// Equivalent code for release builds. VC++ generates the wrong program
		// with optimisations.
		(editSetTimesFrom > -editSetTimesTo)
		[qi::_val = phoenix::bind(&constructEditQueryTimes,
			qi::_1, qi::_2)] |
		(editSetTimesTo)
		[qi::_val = phoenix::bind(&constructEditQueryTimes,
			boost::none, qi::_1)]
#endif
	);
	BOOST_SPIRIT_DEBUG_NODE(editSetTimes);

	editSetTimesFrom %= (space >>
		(qi::lit("from") | qi::lit("after")) > space > time);
	editSetTimesTo %= (space >>
		(qi::lit("by") | qi::lit("before") | qi::lit("to")) > space >
		time);

	editSetSubtask = (
		qi::int_
	)[qi::_val = phoenix::bind(&constructEditQuerySubtask, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(editSetSubtask);

	editSetDependent = (
		qi::int_
	)[qi::_val = phoenix::bind(&constructEditQueryDependent, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(editSetDependent);

	editAttachmentCommandRule = (
		string
	)[qi::_val = phoenix::bind(&constructEditQueryAttachment, qi::_r1, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(editAttachmentCommandRule);
	#pragma endregion

	#pragma region Deleting tasks
	deleteCommand = (
		qi::uint_
	)[qi::_val = phoenix::bind(&constructDeleteQuery, qi::_1)];
	BOOST_SPIRIT_DEBUG_NODE(deleteCommand);
	#pragma endregion

	#pragma region Undoing tasks
	undoCommand = (
		qi::eps
	)[qi::_val = phoenix::construct<UNDO_QUERY>()];
	BOOST_SPIRIT_DEBUG_NODE(undoCommand);
	#pragma endregion

	space = qi::omit[+ParserCharTraits::blank];

	value = (
		(qi::int_) |
		(qi::bool_) |
		taskPriority |
		string
	)[qi::_val = phoenix::bind(&constructValue, qi::_1)];

	taskPriority.add
		(L"normal", TaskPriority::NORMAL)
		(L"high", TaskPriority::HIGH);

	string %= qi::as_wstring[(
		qi::lit('\'') > *stringContents > qi::lit('\'')
	)];
	BOOST_SPIRIT_DEBUG_NODE(string);

	stringContents %= (
		qi::lit("\\'")[qi::_val = '\''] |
		qi::lit("\\\\")[qi::_val = '\\'] |
		(ParserCharTraits::char_ - qi::lit('\''))
	);
	BOOST_SPIRIT_DEBUG_NODE(stringContents);

	qi::on_error<qi::fail>(start,
		phoenix::bind(&onFailure, qi::_1, qi::_2, qi::_3, qi::_4));
}

void QueryParser::onFailure(
	ParserIteratorType /*begin*/,
	ParserIteratorType end,
	ParserIteratorType errorPos,
	const spirit::info& message) {
	StringType lexeme(errorPos, end);
	throw ParseErrorException(message, lexeme);
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\query_parser.cpp





	/**
	 * origin: .\You-NLP\query_parser.h
	 */

#pragma once
#ifndef YOU_NLP_QUERY_PARSER_H_
#define YOU_NLP_QUERY_PARSER_H_

#include <boost/spirit/include/qi.hpp>

#include "parse_tree.h"
#include "parser.h"
#include "date_time_parser.h"

namespace You {
namespace NLP {

/// The query parser that recognises our input syntax.
class QueryParser : public boost::spirit::qi::grammar<
	ParserIteratorType,
	QUERY()> {
public:
	/// The type of the iterator used in this grammar.
	typedef ParserIteratorType IteratorType;

	/// The type of the skipper used in this grammar.
	typedef ParserSkipperType SkipperType;

	/// The type of the lexeme buffer provided in a lexer semantic action.
	typedef std::vector<ParserCharEncoding::char_type> LexemeType;

	/// The type of input strings accepted by this parser.
	typedef std::basic_string<ParserCharEncoding::char_type> StringType;

	/// The type of values on the RHS of any expression in the grammar.
	typedef boost::variant<
		int,
		bool,
		TaskPriority,
		StringType,
		boost::posix_time::ptime> ValueType;

public:
	QueryParser();

	/// Parses the given input string into a date.
	///
	/// \param[in] string The string to parse.
	/// \param[out] result The parsed date/time object.
	/// \return True if parsing was successful.
	static bool parse(const StringType& string, QUERY& result);

	/// Parses the given input string into a query.
	///
	/// \param[in] string The string to parse.
	/// \return The query tree representing the given query.
	/// \exception ParserException When parsing fails.
	static QUERY parse(const StringType& string);

private:
	#pragma region Adding tasks
	/// Process the main task, as well as its subtasks and dependents.
	///
	/// \see addCommandSubtasks
	/// The production rule associated with this semantic action.
	///
	/// \param[in] query The main task
	/// \param[in] subtasks The subtasks provided.
	/// \param[in] dependent The dependent provided.
	/// \return The synthesised value for the \ref addCommandSubtasks rule.
	static ADD_QUERY constructAddQuery(
		ADD_QUERY query,
		boost::optional<ADD_QUERY> dependent,
		boost::optional<std::vector<ADD_QUERY>> subtasks);

	/// Process the terminal returned from the add query string parse rule.
	///
	/// \param[in] description The string from the parser.
	/// \param[in] query The \ref ADD_QUERY parse tree to the right of the
	///                  current terminal.
	/// \return The synthesised value for the \ref addCommand rule.
	static ADD_QUERY constructAddQueryFromDescription(
		StringType description,
		ADD_QUERY query);

	/// Process the terminal returned from the add query character parse rule,
	/// stringing characters together to form the description.
	///
	/// \param[in] lexeme The lexeme from the parser.
	/// \param[in] query The \ref ADD_QUERY parse tree to the right of the
	///                  current character.
	/// \return The synthesised value for the \ref addCommand rule.
	static ADD_QUERY constructAddQueryFromDescription(
		ParserCharEncoding::char_type lexeme,
		ADD_QUERY query);

	/// Process the terminal ! in a task description. Before the deadline, this
	/// indicates a high priority task.
	///
	/// \see addCommandPriority
	/// The production rule associated with this semantic action.
	///
	/// \param[in] query The query from the eoi terminal. This should be an
	///                  \ref ADD_QUERY parse tree, with an optional deadline.
	/// \return The synthesised value for the \ref addCommandPriority rule.
	static ADD_QUERY constructAddQueryWithPriority(ADD_QUERY query);

	/// Process the nonterminal indicating a start time or deadline, converting
	/// it to an appropriate \ref ADD_QUERY type.
	///
	/// \see addCommandTime
	/// The production rule associated with this semantic action.
	///
	/// \param[in] start The start time from the parser.
	/// \param[in] deadline The deadline from the parser.
	/// \return The synthesised value for the \ref addCommandTime rule.
	static ADD_QUERY constructAddQueryWithTime(
		boost::optional<boost::posix_time::ptime> start,
		boost::optional<boost::posix_time::ptime> deadline);

	/// Process the end-of-input nonterminal, potentially including a start
	/// time or deadline. This captures the start time or deadline, if one is
	/// present.
	///
	/// \see addCommandTime
	/// The production rule associated with this semantic action.
	///
	/// \param[in] query The nonterminal from the parser.
	/// \return The synthesised value for the \ref addCommandTime rule.
	static ADD_QUERY constructAddQueryWithOptionalTime(
		boost::optional<ADD_QUERY> query);
	#pragma endregion

	#pragma region Showing tasks
	/// Process the non-terminal returned from the show query parse rule,
	/// constructing the predicates and ordering.
	///
	/// \param[in] filters The filter predicates.
	/// \param[in] ordering The ordering for display.
	/// \return The synthesised value for the \ref showCommand rule.
	static SHOW_QUERY constructShowQuery(
		boost::optional<std::vector<SHOW_QUERY::FIELD_FILTER>> filters,
		boost::optional<std::vector<SHOW_QUERY::FIELD_ORDER>> ordering
	);

	/// Process the terminal returned from the show query filtering parse rule,
	/// constructing one filter.
	///
	/// \param[in] field The field to sort by.
	/// \param[in] predicate the predicate to apply.
	/// \param[in] value The value to compare against the field.
	/// \return The synthesised value for the \ref showQueryFilteringColumn
	///         rule.
	static SHOW_QUERY::FIELD_FILTER constructShowQueryFilteringColumn(
		const TaskField& field,
		const SHOW_QUERY::Predicate& predicate,
		const ValueType& value);

	/// Process the terminal returned from the show query ordering parse rule,
	/// constructing one column's ordering.
	///
	/// \param[in] field The field to sort by.
	/// \param[in] order The order to sort the field by.
	/// \return The synthesised value for the \ref showCommandSortingColumn
	///         rule.
	static SHOW_QUERY::FIELD_ORDER constructShowQuerySortColumn(
		const TaskField& field,
		const boost::optional<SHOW_QUERY::Order> order
	);
	#pragma endregion

	#pragma region Editing tasks
	/// Sets the edit query's task ID.
	///
	/// \param[in] offset The task which the user is referencing.
	static EDIT_QUERY constructEditQuery(
		size_t offset,
		EDIT_QUERY query);

	/// Constructs a edit query from the given parse tree values.
	///
	/// \param[in] field The field which should be edited.
	/// \return The synthesised value for the \ref editCommand rule.
	static EDIT_QUERY constructEditQueryNullary(TaskField field);

	/// Constructs a edit query from the given parse tree values.
	///
	/// \param[in] field The field which should be edited.
	/// \param[in] newValue The new value the user wants to change the field to.
	/// \return The synthesised value for the \ref editCommand rule.
	static EDIT_QUERY constructEditQueryUnary(
		TaskField field,
		ValueType newValue);

	/// Constructs an edit query from the given parse tree values.
	///
	/// \param[in] field The field which should be edited.
	/// \param[in] priority The new value the user wants to change the field to.
	/// \return The synthesised value for the \ref editCommand rule.
	static EDIT_QUERY constructEditQueryPriority(
		TaskPriority priority);

	/// Constructs an edit query which sets the start time or deadline of a task
	/// from the given dates.
	///
	/// \param[in] start The new start time of the task.
	/// \param[in] deadline The new deadline of the task.
	/// \return The synthesised value for the \ref editSetDeadline rule.
	static EDIT_QUERY constructEditQueryTimes(
		boost::optional<boost::posix_time::ptime> start,
		boost::optional<boost::posix_time::ptime> deadline);

	/// Constructs an edit query setting the given task as a subtask of the
	/// first task.
	///
	/// \param[in] subtask The task ID to set as a subtask.
	/// \return The synthesised value for the \ref editCommand rule.
	static EDIT_QUERY constructEditQuerySubtask(int subtask);

	/// Constructs an edit query setting the given task as depending on the
	/// first task.
	///
	/// \param[in] subtask The task ID to set as a dependent.
	/// \return The synthesised value for the \ref editCommand rule.
	static EDIT_QUERY constructEditQueryDependent(int dependent);

	/// Constructs an edit query from the given attachment command.
	///
	/// \param[in] attach True to attach the file, false to detach.
	/// \param[in] file
	/// \return The synthesised value for the \ref editAttachmentCommandRule
	///         rule.
	static EDIT_QUERY constructEditQueryAttachment(
		bool attach,
		StringType file);
	#pragma endregion

	#pragma region Deleting tasks
	/// Constructs a delete query from the given parse tree values.
	///
	/// \param[in] offset The task for which the user is referencing
	/// \return The synthesised value for the \ref deleteCommand rule.
	static DELETE_QUERY constructDeleteQuery(const size_t offset);
	#pragma endregion

	/// Constructs a value from the given lexemes.
	///
	/// \param[in] value The value from the parser.
	/// \return The concrete synthesised value for the \ref value rule.
	static ValueType constructValue(ValueType value);

	/// Handles failures in parsing. This raises a \ref ParseErrorException.
	///
	/// \exception ParseErrorException The exception representing the parse
	///                                error.
	static void onFailure(
		ParserIteratorType begin,
		ParserIteratorType end,
		ParserIteratorType errorPos,
		const boost::spirit::info& message);

private:
	/// The start rule.
	start_type start;

	/// Explicit command rule.
	boost::spirit::qi::rule<IteratorType, QUERY()> explicitCommand;

	#pragma region Adding tasks
	/// Add command rule.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()> addCommand;

	/// Add command description rule.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()> addCommandDescription;

	/// Add command description rule, for quoted descriptions.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()>
		addCommandDescriptionQuoted;

	/// Add command description rule, for unquoted descriptions.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()>
		addCommandDescriptionUnquoted;

	/// Add command description tail rule.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()>
		addCommandDescriptionUnquotedTail;

	/// Add command priority rule.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()> addCommandPriority;

	/// Add command's start time/deadline rule.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()> addCommandTime;

	/// Add command's start time/deadline rule.
	/// This is split in two because of a release build bug in the compiler.
	boost::spirit::qi::rule<IteratorType, boost::posix_time::ptime()>
		addCommandTimeFrom;

	/// Add command's start time/deadline rule.
	/// This is split in two because of a release build bug in the compiler.
	boost::spirit::qi::rule<IteratorType, boost::posix_time::ptime()>
		addCommandTimeTo;

	/// Add command's optional start time/deadline rule. This acts as the
	/// terminal for the add query parser.
	boost::spirit::qi::rule<IteratorType, ADD_QUERY()>
		addCommandTimeOptional;

	/// Add command's subtasks
	boost::spirit::qi::rule<IteratorType, std::vector<ADD_QUERY>()>
		addCommandSubtasks;
	#pragma endregion

	#pragma region Showing tasks
	/// Show command rule.
	boost::spirit::qi::rule<IteratorType, SHOW_QUERY()>
		showCommand;

	/// Show command filtering rule.
	boost::spirit::qi::rule<IteratorType,
		std::vector<SHOW_QUERY::FIELD_FILTER>()>
		showCommandFiltering;

	/// Show command filtering rule for one filter
	boost::spirit::qi::rule<IteratorType,
		SHOW_QUERY::FIELD_FILTER()> showCommandFilteringColumn;

	/// The symbol mapping from task filter predicates to an actual predicate.
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		SHOW_QUERY::Predicate> showCommandFilteringPredicate;

	/// Show command sorting rule for multiple columns.
	boost::spirit::qi::rule<IteratorType,
		std::vector<SHOW_QUERY::FIELD_ORDER>()>
		showCommandSorting;

	/// Show command sorting rule for one column.
	boost::spirit::qi::rule<IteratorType,
		SHOW_QUERY::FIELD_ORDER()> showCommandSortingColumn;

	/// The symbol mapping from task ordering to ascending/descending.
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		SHOW_QUERY::Order> showCommandSortingOrders;

	/// The symbol mapping from task properties to the actual field.
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		TaskField> showCommandFields;
	#pragma endregion

	#pragma region Editing tasks
	/// Edit command rule.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()>
		editCommand;

	/// Edit command nonterminal rule for the fields to set.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()>
		editCommandRule;

	/// Edit command nonterminal rule for unary fields to set.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()>
		editCommandRuleUnary;

	/// Edit command nonterminal rule for nullary fields to set.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()>
		editCommandRuleNullary;

	/// Edit command nonterminal rule for the priority to set.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()>
		editCommandRulePriorities;

	/// The symbol mapping from task properties to the actual field taking an
	/// argument (hence unary).
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		TaskField> editCommandFieldsUnary;

	/// The symbol mapping from task properties to the actual field taking no
	/// arguments (hence nullary).
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		TaskField> editCommandFieldsNullary;

	/// Edit command nonterminal rule for setting the dependency of another
	/// task.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()> editSetDependent;

	/// Edit command nonterminal rule for setting the subtask of another task.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()> editSetSubtask;

	/// Edit command terminal rule for setting the task to be of high priority.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()> editSetHighPriority;

	/// Edit command terminal rule for setting the task start time or deadlines.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY()> editSetTimes;

	/// Edit command terminal rule for setting the task start time or deadlines.
	/// This is split in two because of a release build bug in the compiler.
	boost::spirit::qi::rule<IteratorType, boost::posix_time::ptime()>
		editSetTimesFrom;

	/// Edit command terminal rule for setting the task start time or deadlines.
	/// This is split in two because of a release build bug in the compiler.
	boost::spirit::qi::rule<IteratorType, boost::posix_time::ptime()>
		editSetTimesTo;

	/// Edit command rule for attaching and detaching attachments.
	boost::spirit::qi::rule<IteratorType, EDIT_QUERY(bool)>
		editAttachmentCommandRule;
	#pragma endregion

	#pragma region Deleting tasks
	boost::spirit::qi::rule<IteratorType, DELETE_QUERY()>
		deleteCommand;
	#pragma endregion

	#pragma region Undoing tasks
	/// Undo command rule.
	boost::spirit::qi::rule<IteratorType, UNDO_QUERY()>
		undoCommand;
	#pragma endregion

	#pragma region Utility rules
	/// A utility rule to handle whitespace.
	boost::spirit::qi::rule<IteratorType> space;

	/// A utility rule which converts numbers to ints, booleans to bools,
	/// dates to posix_time::ptime, and strings verbatim.
	boost::spirit::qi::rule<IteratorType, ValueType()> value;

	/// The symbol mapping from priority strings to task priorities.
	boost::spirit::qi::symbols<
		ParserCharEncoding::char_type,
		TaskPriority> taskPriority;

	/// A utility rule which converts raw strings (unquoted) into a
	/// posix_time::ptime.
	DateTimeParser time;

	/// A utility rule which will process all characters verbatim. This is how
	/// the user specifies that he does not want the parser to perform syntax
	/// analysis for this part of the input.
	boost::spirit::qi::rule<IteratorType, StringType()> string;

	/// A utility rule which processes all characters within the quotes of
	/// the verbatim string.
	boost::spirit::qi::rule<IteratorType,
		ParserCharEncoding::char_type()> stringContents;
	#pragma endregion
};

}  // namespace NLP
}  // namespace You

#endif  // YOU_NLP_QUERY_PARSER_H_

	// End of segment: .\You-NLP\query_parser.h





	/**
	 * origin: .\You-NLP\query_parser_actions.cpp
	 */

#include "stdafx.h"
#include "You-Utils/fatal.h"

#include "exception.h"
#include "date_time_parser.h"
#include "query_parser.h"

namespace You {
namespace NLP {

namespace spirit = boost::spirit;
namespace qi = spirit::qi;
namespace phoenix = boost::phoenix;

ADD_QUERY QueryParser::constructAddQuery(
	ADD_QUERY query,
	boost::optional<ADD_QUERY> dependent,
	boost::optional<std::vector<ADD_QUERY>> subtasks) {
	if (static_cast<bool>(subtasks)) {
		query.subtasks = std::move(subtasks.get());
	}
	if (static_cast<bool>(dependent)) {
		query.dependent = std::make_shared<ADD_QUERY>(
			std::move(dependent.get()));
	}

	return query;
}

ADD_QUERY QueryParser::constructAddQueryFromDescription(
	ParserCharEncoding::char_type lexeme,
	ADD_QUERY query) {
	query.description.insert(query.description.begin(), lexeme);
	return query;
}

ADD_QUERY QueryParser::constructAddQueryFromDescription(
	StringType description,
	ADD_QUERY query) {
	query.description = std::move(description);
	return query;
}

ADD_QUERY QueryParser::constructAddQueryWithPriority(ADD_QUERY query) {
	query.priority = TaskPriority::HIGH;
	return query;
}

ADD_QUERY QueryParser::constructAddQueryWithTime(
	boost::optional<boost::posix_time::ptime> start,
	boost::optional<boost::posix_time::ptime> deadline) {
	return ADD_QUERY {
		std::wstring(),
		TaskPriority::NORMAL,
		std::move(start),
		std::move(deadline)
	};
}

ADD_QUERY QueryParser::constructAddQueryWithOptionalTime(
	boost::optional<ADD_QUERY> query) {
	if (query) {
		return query.get();
	} else {
		return ADD_QUERY {
		};
	}
}

SHOW_QUERY QueryParser::constructShowQuery(
	boost::optional<std::vector<SHOW_QUERY::FIELD_FILTER>> filters,
	boost::optional<std::vector<SHOW_QUERY::FIELD_ORDER>> ordering) {
	SHOW_QUERY result;
	if (static_cast<bool>(filters)) {
		result.predicates = std::move(filters.get());
	}
	if (static_cast<bool>(ordering)) {
		result.order = std::move(ordering.get());
	}

	return result;
}

SHOW_QUERY::FIELD_FILTER QueryParser::constructShowQueryFilteringColumn(
	const TaskField& field,
	const SHOW_QUERY::Predicate& predicate,
	const ValueType& value) {
	SHOW_QUERY::FIELD_FILTER result {
		field,
		predicate
	};

	try {
		switch (field) {
		case TaskField::DESCRIPTION:
			result.value = boost::get<StringType>(value);
			break;
		case TaskField::START:
		case TaskField::DEADLINE:
			result.value = boost::get<boost::posix_time::ptime>(value);
			break;
		case TaskField::PRIORITY:
			result.value = boost::get<TaskPriority>(value);
			break;
		case TaskField::COMPLETE:
			result.value = boost::get<bool>(value);
			break;
		default:
			fatal();
		}
	} catch (boost::bad_get&) {
		throw ParserTypeException();
	}

	return result;
}

SHOW_QUERY::FIELD_ORDER QueryParser::constructShowQuerySortColumn(
	const TaskField& field,
	const boost::optional<SHOW_QUERY::Order> order) {
	return SHOW_QUERY::FIELD_ORDER {
		field,
		static_cast<bool>(order) ? order.get() : SHOW_QUERY::Order::ASCENDING
	};
}

EDIT_QUERY QueryParser::constructEditQuery(
	size_t offset,
	EDIT_QUERY query) {
	query.taskID = offset;

	return query;
}

EDIT_QUERY QueryParser::constructEditQueryNullary(TaskField field) {
	EDIT_QUERY result;

	switch (field) {
	case TaskField::COMPLETE:
		result.complete = true;
		break;
	default:
		fatal();
	}

	return result;
}

EDIT_QUERY QueryParser::constructEditQueryUnary(
	TaskField field,
	ValueType newValue) {
	EDIT_QUERY result;

	try {
		switch (field) {
		case TaskField::DESCRIPTION:
			result.description = std::move(boost::get<StringType>(newValue));
			break;
		case TaskField::START:
			result.start = std::move(
				boost::get<boost::posix_time::ptime>(newValue));
			break;
		case TaskField::DEADLINE:
			result.deadline = std::move(
				boost::get<boost::posix_time::ptime>(newValue));
			break;
		default:
			fatal();
		}

		return result;
	} catch (boost::bad_get&) {
		throw ParserTypeException();
	}
}

EDIT_QUERY QueryParser::constructEditQueryPriority(TaskPriority priority) {
	EDIT_QUERY result;
	result.priority = priority;

	return result;
}

EDIT_QUERY QueryParser::constructEditQueryTimes(
	boost::optional<boost::posix_time::ptime> start,
	boost::optional<boost::posix_time::ptime> deadline) {
	EDIT_QUERY result;
	result.start = std::move(start);
	result.deadline = std::move(deadline);

	return result;
}

EDIT_QUERY QueryParser::constructEditQuerySubtask(int subtask) {
	EDIT_QUERY result;
	result.childTask = subtask;

	return result;
}

EDIT_QUERY QueryParser::constructEditQueryDependent(int dependent) {
	EDIT_QUERY result;
	result.dependingTask = dependent;

	return result;
}

EDIT_QUERY QueryParser::constructEditQueryAttachment(
	bool attach,
	StringType file) {
	EDIT_QUERY result;
	result.attachments.push_back({ attach, file });

	return result;
}

DELETE_QUERY QueryParser::constructDeleteQuery(const size_t offset) {
	return DELETE_QUERY {
		offset
	};
}

QueryParser::ValueType QueryParser::constructValue(ValueType value) {
	// Only process if it is a string. It can be a date, in that case.
	if (const StringType* lexeme = boost::get<StringType>(&value)) {
		boost::posix_time::ptime date;
		if (DateTimeParser::parse(
			std::wstring(begin(*lexeme), end(*lexeme)), date)) {
			return date;
		}
	}

	return value;
}

}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP\query_parser_actions.cpp





	/**
	 * origin: .\You-NLP-Tests\date_time_parser_tests.cpp
	 */

#include "stdafx.h"
#include "exception.h"
#include "date_time_parser.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using boost::gregorian::date;
using boost::posix_time::ptime;
using boost::posix_time::hours;

using You::NLP::DateTimeParser;

TEST_CLASS(DateTimeParserTests) {
public:
	TEST_METHOD(rejectsEmptyString) {
		Assert::ExpectException<ParserException>(
			std::bind(static_cast<ptime (*)(const std::wstring&)>(
				&DateTimeParser::parse), L""),
			L"Throws exception on empty string");
	}

	TEST_METHOD(acceptsTrailingWhitespace) {
		DateTimeParser::parse(L"13 nov			");
	}

	TEST_METHOD(throwsExceptionWhenTrailingText) {
		Assert::ExpectException<ParserException>(
			std::bind(static_cast<ptime(*)(const std::wstring&)>(
				&DateTimeParser::parse), L"14 Decembers"));
	}

	TEST_METHOD(parsesYear) {
		Assert::AreEqual(2056,
			static_cast<int>(DateTimeParser::parse(L"2056").date().year()));
	}

	TEST_METHOD(parsesTwoDigitYear) {
		Assert::AreEqual(static_cast<int>(parseTwoDigitYear(13)),
			static_cast<int>(DateTimeParser::parse(L"13").date().year()));
		Assert::AreEqual(static_cast<int>(parseTwoDigitYear(45)),
			static_cast<int>(DateTimeParser::parse(L"45").date().year()));
	}

	TEST_METHOD(parsesStringMonths) {
		std::array<std::wstring, 12> inputs = {
			L"2014-Jan",
			L"2014-Feb",
			L"2014-Mar",
			L"2014-Apr",
			L"2014-May",
			L"2014-Jun",
			L"2014-Jul",
			L"2014-Aug",
			L"2014-Sep",
			L"2014-Oct",
			L"2014-Nov",
			L"2014-Dec"
		};

		for (auto i = inputs.begin(); i != inputs.end(); ++i) {
			const std::wstring& str = *i;
			Assert::AreEqual(i - inputs.begin() + 1,
				static_cast<int>(DateTimeParser::parse(str).date().month()));
		}
	}

	TEST_METHOD(parsesStringMonthsCaseInsensitive) {
		Assert::AreEqual(9, static_cast<int>(
			DateTimeParser::parse(L"2014-sep").date().month()));
	}

	TEST_METHOD(parsesYearWithMonthAsFirstDay) {
		date d = DateTimeParser::parse(L"2014-May").date();

		Assert::AreEqual(2014, static_cast<int>(d.year()));
		Assert::AreEqual(static_cast<int>(boost::gregorian::May),
			static_cast<int>(d.month()));
		Assert::AreEqual(1, static_cast<int>(d.day()));
	}

	TEST_METHOD(parsesMonthWithYear) {
		date d = DateTimeParser::parse(L"may 2014").date();

		Assert::AreEqual(2014, static_cast<int>(d.year()));
		Assert::AreEqual(static_cast<int>(boost::gregorian::May),
			static_cast<int>(d.month()));
		Assert::AreEqual(1, static_cast<int>(d.day()));
	}

	TEST_METHOD(parsesYearMonthDay) {
		date d = DateTimeParser::parse(L"2014-Oct-7").date();
		Assert::AreEqual(date(2014, boost::gregorian::Oct, 7), d);

		d = DateTimeParser::parse(L"2014-11-7").date();
		Assert::AreEqual(date(2014, boost::gregorian::Nov, 7), d);
	}

	TEST_METHOD(parsesDayWithMonth) {
		date d = boost::posix_time::second_clock::local_time().date();
		date actualTomorrow = d + boost::gregorian::days(1);

		date tomorrow = DateTimeParser::parse((
			boost::wformat(L"%1% %2%") %
				actualTomorrow.day() %
				actualTomorrow.month()).str()).date();
		Assert::AreEqual(actualTomorrow, tomorrow);

		date nextYear = d + boost::gregorian::years(1) -
			boost::gregorian::days(1);
		date yesterday = DateTimeParser::parse((
			boost::wformat(L"%1% %2%") %
			nextYear.day() %
			nextYear.month()).str()).date();
		Assert::AreEqual(nextYear, yesterday);
	}

	TEST_METHOD(parsesRelativeMonths) {
		date today = boost::posix_time::second_clock::local_time().date();
		date nextOctober = DateTimeParser::parse(L"next oct").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::months_of_year::Oct),
			static_cast<int>(nextOctober.month()));
		Assert::AreEqual(static_cast<uint16_t>(1),
			nextOctober.day().as_number());
		Assert::IsTrue(nextOctober > today);

		date lastOctober = DateTimeParser::parse(L"last oct").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::months_of_year::Oct),
			static_cast<int>(lastOctober.month()));
		Assert::AreEqual(static_cast<uint16_t>(1),
			lastOctober.day().as_number());
		Assert::IsTrue(lastOctober < today);

		date thisNovember = DateTimeParser::parse(L"this nov").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::months_of_year::Nov),
			static_cast<int>(thisNovember.month()));
		Assert::IsTrue(thisNovember > today);
		Assert::AreEqual(static_cast<uint16_t>(1),
			thisNovember.day().as_number());
		Assert::IsTrue((thisNovember - today).days() <= 366);

		date thisDecember = DateTimeParser::parse(L"this dec").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::months_of_year::Dec),
			static_cast<int>(thisDecember.month()));
		Assert::IsTrue(thisDecember > today);
		Assert::AreEqual(static_cast<uint16_t>(1),
			thisDecember.day().as_number());
		Assert::IsTrue((thisDecember - today).days() <= 366);

		date thisOctober = DateTimeParser::parse(L"this oct").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::months_of_year::Oct),
			static_cast<int>(thisOctober.month()));
		Assert::IsTrue(thisOctober > today);
		Assert::AreEqual(static_cast<uint16_t>(1),
			thisOctober.day().as_number());
		Assert::IsTrue((thisOctober - today).days() <= 366);
	}

	TEST_METHOD(parsesRelativeDaysOfWeek) {
		date today = boost::posix_time::second_clock::local_time().date();
		date nextMonday = DateTimeParser::parse(L"next monday").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::weekdays::Monday),
			static_cast<int>(nextMonday.day_of_week()));
		Assert::IsTrue(nextMonday > today);
		Assert::IsTrue((nextMonday - today).days() <= 13);

		date lastMonday = DateTimeParser::parse(L"last monday").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::weekdays::Monday),
			static_cast<int>(lastMonday.day_of_week()));
		Assert::IsTrue(lastMonday < today);
		Assert::IsTrue((today - lastMonday).days() <= 13);

		date thisSaturday = DateTimeParser::parse(L"this sat").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::weekdays::Saturday),
			static_cast<int>(thisSaturday.day_of_week()));
		Assert::IsTrue(thisSaturday > today);
		Assert::IsTrue((thisSaturday - today).days() <= 7);

		date thisSunday = DateTimeParser::parse(L"this sun").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::weekdays::Sunday),
			static_cast<int>(thisSunday.day_of_week()));
		Assert::IsTrue(thisSunday > today);
		Assert::IsTrue((thisSunday - today).days() <= 7);

		date thisFriday = DateTimeParser::parse(L"this fri").date();
		Assert::AreEqual(
			static_cast<int>(boost::date_time::weekdays::Friday),
			static_cast<int>(thisFriday.day_of_week()));
		Assert::IsTrue(thisFriday > today);
		Assert::IsTrue((thisFriday - today).days() <= 7);
	}

	TEST_METHOD(parsesToday) {
		date today = boost::posix_time::second_clock::local_time().date();
		Assert::AreEqual(today, DateTimeParser::parse(L"today").date());
	}

	TEST_METHOD(parsesTomorrow) {
		date today = boost::posix_time::second_clock::local_time().date();
		date tomorrow = today + boost::gregorian::days(1);

		Assert::AreEqual(tomorrow, DateTimeParser::parse(L"tomorrow").date());
	}

	TEST_METHOD(parsesYesterday) {
		date today = boost::posix_time::second_clock::local_time().date();
		date yesterday = today - boost::gregorian::days(1);

		Assert::AreEqual(yesterday, DateTimeParser::parse(L"yesterday").date());
	}

	TEST_METHOD(parsesRelativeToN) {
		date today = boost::posix_time::second_clock::local_time().date();
		date next = today + boost::gregorian::days(3);

		Assert::AreEqual(next, DateTimeParser::parse(L"3 days").date());

		next = today + boost::gregorian::days(14);
		Assert::AreEqual(next, DateTimeParser::parse(L"2 weeks").date());
	}

private:
	boost::gregorian::greg_year parseTwoDigitYear(DateTimeParser::Year year) {
		return DateTimeParser::parseTwoDigitYear(year);
	}
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\date_time_parser_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\add_query_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using You::NLP::ADD_QUERY;

TEST_CLASS(AddQueryTests) {
public:
	TEST_METHOD(convertsToStream) {
		std::wostringstream stream;
		stream << DUMMY;
		Assert::AreEqual(
			(boost::wformat(L"%1% (start %2%, deadline %3%, normal priority, "
				L"1 subtasks, 1 dependents)") % DESCRIPTION % START %
				DEADLINE).str(),
			stream.str());
	}

	TEST_METHOD(convertsToString) {
		Assert::AreEqual(
			(boost::wformat(L"%1% (start %2%, deadline %3%, normal priority, "
				L"1 subtasks, 1 dependents)") % DESCRIPTION % START %
				DEADLINE).str(),
			boost::lexical_cast<std::wstring>(DUMMY));
	}

	TEST_METHOD(comparesEquality) {
		ADD_QUERY local {
			DESCRIPTION,
			TaskPriority::NORMAL,
			START,
			DEADLINE,
			{ ADD_QUERY { DESCRIPTION } },
			std::shared_ptr<ADD_QUERY>(new ADD_QUERY { DESCRIPTION + L"3" })
		};

		Assert::AreEqual(DUMMY, local);
	}

	TEST_METHOD(comparesInequality) {
		ADD_QUERY local {
			L"x" + DESCRIPTION,
			TaskPriority::NORMAL,
			DEADLINE
		};

		Assert::AreNotEqual(DUMMY, local);

		local.description = DUMMY.description;
		local.priority = TaskPriority::HIGH;
		Assert::AreNotEqual(DUMMY, local);

		local.priority = DUMMY.priority;
		local.deadline = DUMMY.deadline.get() + boost::posix_time::hours(1);
		Assert::AreNotEqual(DUMMY, local);
	}

private:
	/// The dummy description.
	static const std::wstring DESCRIPTION;

	/// The dummy start time.
	static const boost::posix_time::ptime START;

	/// The dummy deadline.
	static const boost::posix_time::ptime DEADLINE;

	/// A dummy object.
	static const ADD_QUERY DUMMY;
};

const std::wstring AddQueryTests::DESCRIPTION(L"Hello world");
const boost::posix_time::ptime AddQueryTests::START(
	boost::gregorian::date(2010, boost::gregorian::Dec, 3),
	boost::posix_time::hours(0));
const boost::posix_time::ptime AddQueryTests::DEADLINE(
	boost::gregorian::date(2010, boost::gregorian::Dec, 4),
	boost::posix_time::hours(0));
const ADD_QUERY AddQueryTests::DUMMY {
	DESCRIPTION,
	TaskPriority::NORMAL,
	START,
	DEADLINE,
	{ ADD_QUERY { DESCRIPTION } },
	std::shared_ptr<ADD_QUERY>(new ADD_QUERY { DESCRIPTION + L"3" })
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\add_query_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\delete_query_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using You::NLP::DELETE_QUERY;

TEST_CLASS(DeleteQueryTests) {
public:
	TEST_METHOD(convertsToStream) {
		std::wostringstream stream;
		stream << DUMMY;
		Assert::AreEqual(
			std::wstring(L"Delete task #1"),
			stream.str());
	}

	TEST_METHOD(convertsToString) {
		Assert::AreEqual(
			std::wstring(L"Delete task #1"),
			boost::lexical_cast<std::wstring>(DUMMY));
	}

	TEST_METHOD(comparesEquality) {
		DELETE_QUERY local = DUMMY;

		Assert::AreEqual(DUMMY, local);
	}

	TEST_METHOD(comparesInequality) {
		DELETE_QUERY local{
			2
		};

		Assert::AreNotEqual(DUMMY, local);
	}

private:
	/// A dummy object.
	static const DELETE_QUERY DUMMY;
};

const DELETE_QUERY DeleteQueryTests::DUMMY {
	1
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\delete_query_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\edit_query_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using You::NLP::EDIT_QUERY;

TEST_CLASS(EditQueryTests) {
public:
	TEST_METHOD(convertsToStream) {
		{
			std::wostringstream stream;
			stream << DUMMY;
			Assert::AreEqual(
				std::wstring(L"Edit task #1 (Description => the lols)"),
				stream.str());
		}

		{  // NOLINT(whitespace/braces)
			EDIT_QUERY local = DUMMY;
			local.deadline = boost::posix_time::ptime(
				boost::gregorian::date(1970, boost::gregorian::Jan, 1),
				boost::posix_time::hours(0));

			std::wostringstream stream;
			stream << local;
			Assert::AreEqual(
				std::wstring(L"Edit task #1 (Description => the lols, "
					L"Deadline => 1970-Jan-01 00:00:00)"),
				stream.str());
		}

		{  // NOLINT(whitespace/braces)
			EDIT_QUERY local = DUMMY;
			local.priority = TaskPriority::HIGH;

			std::wostringstream stream;
			stream << local;
			Assert::AreEqual(
				std::wstring(L"Edit task #1 (Description => the lols, "
				L"Priority => 1)"),
				stream.str());
		}

		{  // NOLINT(whitespace/braces)
			EDIT_QUERY local = DUMMY;
			local.attachments = {
				{ false, L"file:///remove" },
				{ true, L"file:///add" }
			};

			std::wostringstream stream;
			stream << local;
			Assert::AreEqual(
				std::wstring(L"Edit task #1 (Description => the lols, "
				L"Attachments => remove file:///remove, add file:///add)"),
				stream.str());
		}
	}

	TEST_METHOD(convertsToString) {
		Assert::AreEqual(
			std::wstring(L"Edit task #1 (Description => the lols)"),
			boost::lexical_cast<std::wstring>(DUMMY));
	}

	TEST_METHOD(comparesEquality) {
		EDIT_QUERY local = DUMMY;

		Assert::AreEqual(DUMMY, local);
	}

	TEST_METHOD(comparesInequality) {
		EDIT_QUERY local {
			DUMMY.taskID,
			DUMMY.description
		};

		Assert::AreEqual(DUMMY, local);

		EDIT_QUERY local2 = local;
		local2.taskID++;
		Assert::AreNotEqual(DUMMY, local2);

		local2 = local;
		local2.description = std::wstring(L"");
		Assert::AreNotEqual(DUMMY, local2);

		local2 = local;
		local2.start = boost::posix_time::ptime(
			boost::gregorian::date(1970, 1, 1),
			boost::posix_time::hours(1));
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.deadline = boost::posix_time::ptime(
			boost::gregorian::date(1970, 1, 1),
			boost::posix_time::hours(1));
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.priority = TaskPriority::HIGH;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.complete = true;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.childTask = 1;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.dependingTask = 1;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.attachments = { { true, L"file://lol" } };
		Assert::AreNotEqual(local, local2);
	}

private:
	/// A dummy object.
	static const EDIT_QUERY DUMMY;
};

const EDIT_QUERY EditQueryTests::DUMMY {
	1,
	L"the lols"
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\edit_query_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\show_query_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

TEST_CLASS(ShowQueryTests) {
	TEST_METHOD(convertsToStream) {
		std::wostringstream stream;
		stream << DUMMY;
		Assert::AreEqual(
			std::wstring(L"Show tasks (criteria Description=, sort by "
				L"Description ascending)"),
			stream.str());
	}

	TEST_METHOD(convertsToString) {
		Assert::AreEqual(
			std::wstring(L"Show tasks (criteria Description=, sort by "
				L"Description ascending)"),
			boost::lexical_cast<std::wstring>(DUMMY));
	}

	TEST_METHOD(comparesEquality) {
		SHOW_QUERY local = DUMMY;

		Assert::AreEqual(DUMMY, local);
	}

	TEST_METHOD(comparesInequality) {
		SHOW_QUERY local {
			{
				{
					TaskField::DESCRIPTION,
					SHOW_QUERY::Predicate::EQ,
					std::wstring(L"")
				}
			},
			{
				{ TaskField::DESCRIPTION, SHOW_QUERY::Order::ASCENDING }
			}
		};

		Assert::AreEqual(DUMMY, local);

		local.order[0].field = TaskField::DEADLINE;
		Assert::AreNotEqual(DUMMY, local);

		local = DUMMY;
		local.order.push_back(SHOW_QUERY::FIELD_ORDER {
			TaskField::DESCRIPTION
		});
		Assert::AreNotEqual(DUMMY, local);

		local = DUMMY;
		local.predicates.emplace_back(SHOW_QUERY::FIELD_FILTER {
			TaskField::DESCRIPTION,
			SHOW_QUERY::Predicate::EQ,
			std::wstring()
		});
		Assert::AreNotEqual(DUMMY, local);

		SHOW_QUERY local2 = local;
		local2.predicates.push_back(local2.predicates[0]);
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.predicates[0].field = TaskField::PRIORITY;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.predicates[0].predicate = SHOW_QUERY::Predicate::GREATER_THAN;
		Assert::AreNotEqual(local, local2);

		local2 = local;
		local2.predicates[0].value = std::wstring(L"not empty");
		Assert::AreNotEqual(local, local2);
	}

private:
	/// A dummy object.
	static const SHOW_QUERY DUMMY;
};

const SHOW_QUERY ShowQueryTests::DUMMY {
	{ {
		TaskField::DESCRIPTION,
		SHOW_QUERY::Predicate::EQ,
		std::wstring(L"")
		} },
	{ { TaskField::DESCRIPTION, SHOW_QUERY::Order::ASCENDING } }
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\show_query_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\task_field_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

TEST_CLASS(TaskFieldTests) {
	TEST_METHOD(fieldsBinaryOr) {
		TaskField lhs = TaskField::COMPLETE;
		TaskField rhs = TaskField::PRIORITY;

		Assert::AreEqual(
			static_cast<size_t>(lhs) | static_cast<size_t>(rhs),
			static_cast<size_t>(lhs | rhs));
	}

	TEST_METHOD(fieldsBinaryAnd) {
		TaskField lhs = TaskField::COMPLETE;
		TaskField rhs = TaskField::PRIORITY;

		Assert::AreEqual(
			static_cast<size_t>(lhs)& static_cast<size_t>(rhs),
			static_cast<size_t>(lhs & rhs));
	}

	TEST_METHOD(emptyFieldConvertsToEmptyString) {
		Assert::AreEqual(
			std::wstring(),
			boost::lexical_cast<std::wstring>(TaskField::NONE));
	}
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\task_field_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\parse_tree\undo_query_tests.cpp
	 */

#include "stdafx.h"
#include "parse_tree.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using You::NLP::UNDO_QUERY;

TEST_CLASS(UndoQueryTests) {
	TEST_METHOD(convertsToStream) {
		std::wostringstream stream;
		stream << DUMMY;
		Assert::AreEqual(
			std::wstring(L"undo"),
			stream.str());
	}

	TEST_METHOD(convertsToString) {
		Assert::AreEqual(
			std::wstring(L"undo"),
			boost::lexical_cast<std::wstring>(DUMMY));
	}

	TEST_METHOD(comparesEquality) {
		UNDO_QUERY local = DUMMY;

		Assert::AreEqual(DUMMY, local);
	}

	TEST_METHOD(comparesInequality) {
		UNDO_QUERY local;

		Assert::IsFalse(!(DUMMY == local));
	}

private:
	/// A dummy object.
	static const UNDO_QUERY DUMMY;
};

const UNDO_QUERY UndoQueryTests::DUMMY;

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\parse_tree\undo_query_tests.cpp





	/**
	 * origin: .\You-NLP-Tests\query_parser_tests.cpp
	 */

#include "stdafx.h"
#include "You-QueryEngine/task_model.h"

#include "exception.h"
#include "query_parser.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace NLP {
namespace UnitTests {

using boost::gregorian::date;
using boost::posix_time::ptime;
using boost::posix_time::hours;
using You::NLP::ParserException;

using You::NLP::QueryParser;
using You::NLP::ADD_QUERY;
using You::NLP::EDIT_QUERY;
using You::NLP::QUERY;

TEST_CLASS(QueryParserTests) {
public:
	TEST_METHOD(throwsExceptionOnEmptyString) {
		Assert::ExpectException<ParserException>(
			std::bind(static_cast<QUERY (*)(const std::wstring&)>(
				&QueryParser::parse), L""));
	}

	TEST_METHOD(throwsExceptionWhenParseFails) {
		// "throw" is currently not defined, so this should work.
		Assert::ExpectException<ParserException>(
			std::bind(static_cast<QUERY (*)(const std::wstring&)>(
				&QueryParser::parse), L"/throw"));
	}

	TEST_METHOD(throwsExceptionWhenTrailingText) {
		Assert::ExpectException<ParserException>(
			std::bind(static_cast<QUERY(*)(const std::wstring&)>(
				&QueryParser::parse), L"lol by 14 Decembers"));
	}

	TEST_METHOD(acceptsTrailingWhitespace) {
		QueryParser::parse(L"/show		");
	}

	TEST_METHOD(parsesStringAsTask) {
		QUERY q = QueryParser::parse(L"win");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win"
		}), q);

		q = QueryParser::parse(L"win lottery");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win lottery"
		}), q);
	}

	TEST_METHOD(parsesStringWithStartAsTask) {
		QUERY q = QueryParser::parse(L"win from may 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win",
			TaskPriority::NORMAL,
			ptime(date(2014, boost::gregorian::May, 1), hours(0))
		}), q);

		q = QueryParser::parse(L"win lottery from dec 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win lottery",
			TaskPriority::NORMAL,
			ptime(date(2014, boost::gregorian::Dec, 1), hours(0))
		}), q);
	}

	TEST_METHOD(parsesStringWithStartAndDeadlineAsTask) {
		QUERY q = QueryParser::parse(L"win from may 2014 to jun 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win",
			TaskPriority::NORMAL,
			ptime(date(2014, boost::gregorian::May, 1), hours(0)),
			ptime(date(2014, boost::gregorian::Jun, 1), hours(0))
		}), q);

		q = QueryParser::parse(L"win lottery from dec 2014 to jun 2015");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win lottery",
			TaskPriority::NORMAL,
			ptime(date(2014, boost::gregorian::Dec, 1), hours(0)),
			ptime(date(2015, boost::gregorian::Jun, 1), hours(0))
		}), q);
	}

	TEST_METHOD(parsesStringWithDeadlineAsTask) {
		QUERY q = QueryParser::parse(L"win by may 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2014, boost::gregorian::May, 1), hours(0))
		}), q);

		q = QueryParser::parse(L"win lottery by dec 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win lottery",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2014, boost::gregorian::Dec, 1), hours(0))
		}), q);
	}

	TEST_METHOD(parsesStringWithPriorityAsTask) {
		QUERY q = QueryParser::parse(L"win!");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win",
			TaskPriority::HIGH
		}), q);

		q = QueryParser::parse(L"win lottery! by dec 2014");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"win lottery",
			TaskPriority::HIGH,
			boost::none,
			ptime(date(2014, boost::gregorian::Dec, 1), hours(0))
		}), q);
	}

	TEST_METHOD(parsesStringWithSubtasksAsTask) {
		QUERY q = QueryParser::parse(L"Walk the dog by 20 oct : Eat breakfast "
			L"; Take out the dog; Open the door; Buy a new collar by 12 oct");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"Walk the dog",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2015, boost::gregorian::Oct, 20)),
			{
				{ L"Eat breakfast" },
				{ L"Take out the dog" },
				{ L"Open the door" },
				{
					L"Buy a new collar",
					TaskPriority::NORMAL,
					boost::none,
					ptime(date(2015, boost::gregorian::Oct, 12))
				}
			}
		}), q);
	}

	TEST_METHOD(parsesStringWithDependenciesAsTask) {
		QUERY q = QueryParser::parse(L"Buy her flower by 14 dec -> Ask her "
			L"out -> Confess to her by 16 dec");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"Buy her flower",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2014, boost::gregorian::Dec, 14)),
			{},
			std::shared_ptr<ADD_QUERY>(new ADD_QUERY {
				L"Ask her out",
				TaskPriority::NORMAL,
				boost::none,
				boost::none,
				{},
				std::shared_ptr<ADD_QUERY>(new ADD_QUERY {
					L"Confess to her",
					TaskPriority::NORMAL,
					boost::none,
					ptime(date(2014, boost::gregorian::Dec, 16))
				})
			})
		}), q);
	}

	TEST_METHOD(parsesStringWithDependenciesAndSubtasksAsTask) {
		QUERY q = QueryParser::parse(L"Walk the dog by 20 oct : Eat breakfast "
			L"; Take out the dog; Buy her flower by 14 dec -> Ask her "
			L"out by 15 dec -> Confess to her by 16 dec; Buy a new collar by "
			L"12 oct");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"Walk the dog",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2015, boost::gregorian::Oct, 20)),
			{
				{ L"Eat breakfast" },
				{ L"Take out the dog" },
				{
					L"Buy her flower",
					TaskPriority::NORMAL,
					boost::none,
					ptime(date(2014, boost::gregorian::Dec, 14)),
					{},
					std::shared_ptr<ADD_QUERY>(new ADD_QUERY {
						L"Ask her out",
						TaskPriority::NORMAL,
						boost::none,
						ptime(date(2014, boost::gregorian::Dec, 15)),
						{},
						std::shared_ptr<ADD_QUERY>(new ADD_QUERY {
							L"Confess to her",
							TaskPriority::NORMAL,
							boost::none,
							ptime(date(2014, boost::gregorian::Dec, 16))
						})
					})
				},
				{
					L"Buy a new collar",
					TaskPriority::NORMAL,
					boost::none,
					ptime(date(2015, boost::gregorian::Oct, 12))
				}
			}
		}), q);
	}

	TEST_METHOD(parsesIrregularSpacingAddTask) {
		QUERY q;
		Assert::ExpectException<ParseErrorException>(
			boost::phoenix::bind(&QueryParser::parse,
				L"/adds Hello World by 20 oct"));

		q = QueryParser::parse(L"/add E by 22 oct");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"E",
			TaskPriority::NORMAL,
			boost::none,
			ptime(date(2015, boost::gregorian::Oct, 22), hours(0))
		}), q);
	}

	TEST_METHOD(parsesQuotedDescriptionAddTask) {
		QUERY q = QueryParser::parse(L"'CS3235: Homework Assignment 3'! by "
			L"14 Dec 13 ");

		Assert::AreEqual(QUERY(ADD_QUERY {
			L"CS3235: Homework Assignment 3",
			TaskPriority::HIGH,
			boost::none,
			ptime(date(2014, boost::gregorian::Dec, 13))
		}), q);
	}

	TEST_METHOD(parsesShowQuery) {
		// Boundary case: no filters nor sorts.
		QUERY q = QueryParser::parse(L"/show");

		Assert::AreEqual(QUERY(SHOW_QUERY {
			{}, {}
		}), q);

		// Boundary case: one filter, zero sort.
		q = QueryParser::parse(L"/show description='\\\\\\'meh'");

		Assert::AreEqual(QUERY(SHOW_QUERY {
			{
				{
					TaskField::DESCRIPTION,
					SHOW_QUERY::Predicate::EQ,
					std::wstring(L"\\\'meh")
				}
			},
			{}
		}), q);

		q = QueryParser::parse(L"/show description~'meh'");

		Assert::AreEqual(QUERY(SHOW_QUERY {
				{
					{
						TaskField::DESCRIPTION,
						SHOW_QUERY::Predicate::SIMILAR,
						std::wstring(L"meh")
					}
				},
				{}
		}), q);

		// Boundary case: more than one filter, zero sort.
		q = QueryParser::parse(L"/show description!='\\\\\\'meh', "
			L"priority<high");

		Assert::AreEqual(QUERY(SHOW_QUERY {
				{
					{
						TaskField::DESCRIPTION,
						SHOW_QUERY::Predicate::NOT_EQ,
						std::wstring(L"\\\'meh")
					},
					{
						TaskField::PRIORITY,
						SHOW_QUERY::Predicate::LESS_THAN,
						TaskPriority::HIGH
					}
				},
				{}
		}), q);

		// Boundary case: zero filter, one sort.
		q = QueryParser::parse(L"/show order by description ascending");

		Assert::AreEqual(QUERY(SHOW_QUERY {
			{},
			{ { TaskField::DESCRIPTION, SHOW_QUERY::Order::ASCENDING } }
		}), q);

		// Boundary case: zero filter, more than one sort.
		q = QueryParser::parse(L"/show order by description descending, "
			L"priority");

		Assert::AreEqual(QUERY(SHOW_QUERY {
			{},
			{
				{ TaskField::DESCRIPTION, SHOW_QUERY::Order::DESCENDING },
				{ TaskField::PRIORITY, SHOW_QUERY::Order::ASCENDING }
			}
		}), q);

		// Boundary case: nonzero filter, nonzero sort.
		q = QueryParser::parse(L"/show description!='\\\\\\'meh', "
			L"priority<high, priority>normal, deadline>='3 oct', "
			L"deadline<='7 oct', complete=true "
			L"order by description descending, priority");

		Assert::AreEqual(QUERY(SHOW_QUERY {
			{
				{
					TaskField::DESCRIPTION,
					SHOW_QUERY::Predicate::NOT_EQ,
					std::wstring(L"\\\'meh")
				},
				{
					TaskField::PRIORITY,
					SHOW_QUERY::Predicate::LESS_THAN,
					TaskPriority::HIGH
				},
				{
					TaskField::PRIORITY,
					SHOW_QUERY::Predicate::GREATER_THAN,
					TaskPriority::NORMAL
				},
				{
					TaskField::DEADLINE,
					SHOW_QUERY::Predicate::GREATER_THAN_EQ,
					boost::posix_time::ptime(
						boost::gregorian::date(2015, 10, 3),
						boost::posix_time::hours(0))
				},
				{
					TaskField::DEADLINE,
					SHOW_QUERY::Predicate::LESS_THAN_EQ,
					boost::posix_time::ptime(
						boost::gregorian::date(2015, 10, 7),
						boost::posix_time::hours(0))
				},
				{
					TaskField::COMPLETE,
					SHOW_QUERY::Predicate::EQ,
					true
				}
			},
			{
				{ TaskField::DESCRIPTION, SHOW_QUERY::Order::DESCENDING },
				{ TaskField::PRIORITY, SHOW_QUERY::Order::ASCENDING }
			}
		}), q);
	}

	TEST_METHOD(parsesShowQueryWithWrongType) {
		Assert::ExpectException<ParserTypeException>(
			std::bind(static_cast<
				QUERY (*)(const QueryParser::StringType& string)>(
					&QueryParser::parse), L"/show description=false"));
	}

	TEST_METHOD(parsesEditQuery) {
		QUERY q = QueryParser::parse(L"/edit 10 set description='meh'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			L"meh"
		}), q);

		q = QueryParser::parse(L"/edit 10 set description='meh with spaces'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			L"meh with spaces"
		}), q);

		q = QueryParser::parse(L"/edit 10 set start='oct 2014'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			boost::none,
			ptime(date(2014, boost::gregorian::Oct, 1), hours(0))
		}), q);

		q = QueryParser::parse(L"/edit 10 set deadline='oct 2014'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			boost::none,
			boost::none,
			ptime(date(2014, boost::gregorian::Oct, 1), hours(0))
		}), q);

		q = QueryParser::parse(L"/edit 10 set complete");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			true
		}), q);

		q = QueryParser::parse(L"/edit 10 set priority=high");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			TaskPriority::HIGH
		}), q);
	}

	TEST_METHOD(parsesEditHighPriorityQuery) {
		QUERY q = QueryParser::parse(L"/edit 0!");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			TaskPriority::HIGH
		}), q);
	}

	TEST_METHOD(parsesEditDeadlineQuery) {
		QUERY q = QueryParser::parse(L"/edit 0 by 2014-Dec-13");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			boost::none,
			boost::none,
			boost::posix_time::ptime(
				boost::gregorian::date(2014, boost::gregorian::Dec, 13))
		}), q);
	}

	TEST_METHOD(parsesEditStartDateQuery) {
		QUERY q = QueryParser::parse(L"/edit 0 from 2014-Dec-13");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			boost::none,
			boost::posix_time::ptime(
				boost::gregorian::date(2014, boost::gregorian::Dec, 13))
		}), q);
	}

	TEST_METHOD(parsesEditStartDateAndDeadlineQuery) {
		QUERY q = QueryParser::parse(L"/edit 0 from 2014-Dec-13 to 2015-Dec");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			boost::none,
			boost::posix_time::ptime(
				boost::gregorian::date(2014, boost::gregorian::Dec, 13)),
			boost::posix_time::ptime(
				boost::gregorian::date(2015, boost::gregorian::Dec, 1))
		}), q);
	}

	TEST_METHOD(parsesEditSubtaskQuery) {
		QUERY q = QueryParser::parse(L"/edit 0:1");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			1
		}), q);
	}

	TEST_METHOD(parsesEditDependentQuery) {
		QUERY q = QueryParser::parse(L"/edit 0->1");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			0,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			1
		}), q);
	}

	TEST_METHOD(parsesEditAttachmentQuery) {
		QUERY q = QueryParser::parse(L"/edit 10 attach 'lol'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			{ { true, L"lol" } }
		}), q);

		q = QueryParser::parse(L"/edit 10 detach 'lol'");

		Assert::AreEqual(QUERY(EDIT_QUERY {
			10,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			boost::none,
			{ { false, L"lol" } }
		}), q);
	}

	TEST_METHOD(parsesEditQueryWithWrongType) {
		Assert::ExpectException<ParserTypeException>(
			std::bind(static_cast<QUERY (*)(const std::wstring&)>(
				&QueryParser::parse),
				L"/edit 10 set description='14 oct'"));
	}

	TEST_METHOD(parsesDeleteQuery) {
		QUERY q = QueryParser::parse(L"/delete 10");

		Assert::AreEqual(QUERY(DELETE_QUERY {
			10
		}), q);

		Assert::ExpectException<ParseErrorException>(std::bind(
			static_cast<QUERY (*)(const std::wstring&)>(
				&QueryParser::parse), L"/delete10"));
	}

	TEST_METHOD(parsesUndoQuery) {
		QUERY q = QueryParser::parse(L"/undo");

		Assert::AreEqual(QUERY(UNDO_QUERY {}), q);
	}
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

	// End of segment: .\You-NLP-Tests\query_parser_tests.cpp





	/**
	 * origin: .\You-Utils\algorithms.cpp
	 */

#include "stdafx.h"
#include "algorithms.h"

namespace You {
namespace Utils {

template<typename CharT>
bool similar_to<std::basic_string<CharT>>::operator()(
	StringType lhs,
	StringType rhs) {
	std::vector<StringType> needles;
	boost::to_lower(rhs);
	boost::split(needles, rhs, boost::is_space(), boost::token_compress_on);

	std::vector<StringType> haystacks;
	boost::to_lower(lhs);
	boost::split(haystacks, lhs, boost::is_space(), boost::token_compress_on);

	return std::all_of(begin(needles), end(needles),
		std::bind(&isAnyNeedleInHaystacks, std::placeholders::_1, haystacks));
}

template<typename CharT>
bool similar_to<std::basic_string<CharT>>::isAnyNeedleInHaystacks(
	const StringType& needle,
	const std::vector<StringType>& haystacks) {
	assert(!haystacks.empty());
	return std::any_of(begin(haystacks), end(haystacks),
		std::bind(&isNeedleInHaystack, needle, std::placeholders::_1));
}

template<typename CharT>
bool similar_to<std::basic_string<CharT>>::isNeedleInHaystack(
	const StringType& needle,
	const StringType& haystack) {
	if (needle.empty()) {
		return false;
	} else {
		return haystack.find(needle) != StringType::npos;
	}
}

template struct similar_to<std::wstring>;
template struct similar_to<std::string>;

}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils\algorithms.cpp





	/**
	 * origin: .\You-Utils\algorithms.h
	 */

#pragma once
#ifndef YOU_UTILS_ALGORITHMS_H_
#define YOU_UTILS_ALGORITHMS_H_

#include <algorithm>
#include <string>

namespace You {
namespace Utils {

/// Implements a functor which compares the similarity of two objects.
///
/// By default this implements equality.
///
/// \tparam T The type of the operands.
template<typename T>
struct similar_to : public std::equal_to<T> {
};

template<typename CharT>
struct similar_to<std::basic_string<CharT>> {
	typedef std::basic_string<CharT> StringType;

	/// Compares two strings for similarity.
	///
	/// This will tokenise rhs and lhs, and see if any of the tokens in rhs are
	/// substrings of lhs.
	///
	/// \return True if rhs matches anything in lhs.
	bool operator()(StringType lhs, StringType rhs);

private:
	/// Checks the needle is in any haystack.
	///
	/// \param[in] needle The needle to search for.
	/// \param[in] haystacks The haystacks to search.
	/// \return True if the needle is in any haystack. If the haystacks are
	///         empty, returns false.
	static bool isAnyNeedleInHaystacks(const StringType& needle,
		const std::vector<StringType>& haystacks);

	/// Checks if the given needle is in the given haystack.
	///
	/// \param[in] needle The needle to search for
	/// \param[in] haystack The haystack to search.
	/// \return True if any needle is in the haystack. If the haystack is empty,
	///         returns false.
	static bool isNeedleInHaystack(const StringType& needle,
		const StringType& haystack);
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_ALGORITHMS_H_

	// End of segment: .\You-Utils\algorithms.h





	/**
	 * origin: .\You-Utils\exceptions\exception.h
	 */

#pragma once
#ifndef YOU_UTILS_EXCEPTIONS_EXCEPTION_H_
#define YOU_UTILS_EXCEPTIONS_EXCEPTION_H_

#include <stdexcept>

// http://stackoverflow.com/questions/3585144
// Basically: the warning is a false positive.
#pragma warning(disable: 4672 4673)

namespace You {
namespace Utils {

class Exception : virtual public std::exception {
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_EXCEPTIONS_EXCEPTION_H_

	// End of segment: .\You-Utils\exceptions\exception.h





	/**
	 * origin: .\You-Utils\fatal.h
	 */

#pragma once
#ifndef YOU_UTILS_FATAL_H_
#define YOU_UTILS_FATAL_H_

// These macros are not following naming convention because it must look like
// a function call for code coverage purposes.
#if defined(CODECOVERAGE)
	#define fatal() {}
#else
	#define fatal() assert(false); abort()
#endif

#endif  // YOU_UTILS_FATAL_H_

	// End of segment: .\You-Utils\fatal.h





	/**
	 * origin: .\You-Utils\log\log.cpp
	 */

#include "stdafx.h"
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/format.hpp>
#include "log.h"

namespace You {
namespace Utils {

Logger Log::debug(LogSeverity::DEBUG);
Logger Log::info(LogSeverity::INFO);
Logger Log::warning(LogSeverity::WARNING);
Logger Log::error(LogSeverity::ERROR);
Logger Log::critical(LogSeverity::CRITICAL);

#ifdef _DEBUG
LogSeverity Log::logLevel = LogSeverity::DEBUG;
#else
LogSeverity Log::logLevel = LogSeverity::WARNING;
#endif
std::shared_ptr<LogSink> Log::sink;

namespace {

/// The format for debug messages.
const boost::wformat DEBUG_FORMAT(L"[%1%] <%2%>%3% %4%\n");

/// The format for categories.
const boost::wformat CATEGORY_FORMAT(L"[%1%]");

class DebugLogger : public You::Utils::LogSink {
	void onLog(You::Utils::LogSeverity severity,
		const std::wstring& category,
		const std::wstring& message) override {
		std::wstring categoryString;
		if (!category.empty()) {
			categoryString = (boost::wformat(CATEGORY_FORMAT) % category).str();
		}

		OutputDebugStringW(
			(boost::wformat(DEBUG_FORMAT) %
			boost::posix_time::second_clock::local_time() %
			static_cast<int>(severity) %
			category %
			message).str().c_str());
	}
};

class SetDefaultLogger {
public:
	SetDefaultLogger() {
		You::Utils::Log::restoreSink();
	}
};

SetDefaultLogger setDefault;

}  // namespace

void Log::restoreSink() {
	setSink(std::make_shared<DebugLogger>());
}

void Log::write(
	LogSeverity severity,
	const std::wstring& category,
	const std::wstring& message) {
	if (severity >= Log::logLevel && sink) {
		sink->onLog(severity, category, message);
	}
}

}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils\log\log.cpp





	/**
	 * origin: .\You-Utils\log\log.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_LOG_H_
#define YOU_UTILS_LOG_LOG_H_

#include <memory>

#include "logger.h"
#include "log_severity.h"
#include "log_sink.h"

namespace You {
namespace Utils {

/// The main Logging class.
///
/// This handles all log requests from the various components, and manages the
/// active log sink as well as the active log level.
///
/// This is NOT a singleton because then the syntax for writing to the log would
/// be very clumsy, i.e.
///
/// Log::get().debug << "message"
class Log {
	friend class Logger;

public:
	/// The logger which prints debug-level messages.
	///
	/// \see LogSeverity
	static Logger debug;

	/// The logger which prints info-level messages.
	///
	/// \see LogSeverity
	static Logger info;

	/// The logger which prints warning-level messages.
	///
	/// \see LogSeverity
	static Logger warning;

	/// The logger which prints error-level messages.
	///
	/// \see LogSeverity
	static Logger error;

	/// The logger which prints critical-level messages.
	///
	/// \see LogSeverity
	static Logger critical;

	/// Gets the active log level.
	///
	/// The active log level is the minimum severity for which messages must be
	/// before it will be written to the log sink.
	///
	/// \return The active log level.
	inline static LogSeverity getLogLevel() {
		return logLevel;
	}

	/// Sets the active log level.
	///
	/// \see getLogLevel
	/// See this to understand about log levels.
	///
	/// \param[in] severity The new active log level to set.
	static void setLogLevel(LogSeverity severity) {
		Log::logLevel = severity;
	}

	/// Sets the active log sink.
	///
	/// The active log sink receives all the messages which are at or above the
	/// active log level.
	///
	/// \param[in] sink The new sink to use.
	static void setSink(std::shared_ptr<LogSink> sink) {
		Log::sink = sink;
	}

	/// Restores the default log sink.
	static void restoreSink();

private:
	Log() = delete;

	/// Writes the given message to the log sink.
	///
	/// \param[in] severity The severity of the message.
	/// \param[in] category The category of the message.
	/// \param[in] message The message for the log entry.
	static void write(
		LogSeverity severity,
		const std::wstring& category,
		const std::wstring& message);

private:
	/// The active log level.
	static LogSeverity logLevel;

	/// The active log sink.
	static std::shared_ptr<LogSink> sink;
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_LOG_LOG_H_

	// End of segment: .\You-Utils\log\log.h





	/**
	 * origin: .\You-Utils\log\logger.cpp
	 */

#include "stdafx.h"
#include "log.h"
#include "logger.h"

namespace You {
namespace Utils {

Logger::Logger(LogSeverity severity)
: severity(severity) {
}

bool Logger::isActive() const {
	return Log::getLogLevel() <= severity;
}

void Logger::write(const std::wstring& message, const std::wstring& category) {
	if (isActive()) {
		Log::write(severity, category, message);
	}
}

}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils\log\logger.cpp





	/**
	 * origin: .\You-Utils\log\logger.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_LOGGER_H_
#define YOU_UTILS_LOG_LOGGER_H_

#include <string>
#include <boost/lexical_cast.hpp>

#include "log_message.h"
#include "log_severity.h"

namespace You {
namespace Utils {

/// This \ref Logger class deals with logging one severity of message. It can
/// also be used to specify the category of the message, using operator[].
///
/// \ref Logger instances instantiate \ref LogMessage objects, which when
/// destroyed, flushes the message to the log.
///
/// \ref LogMessage objects lazily evaluate their arguments, so that no
/// computation overhead is incurred if the message is not used (because of
/// filtering)
class Logger {
	friend class Log;

public:
	/// Returns a new \ref LogMessage that has the given category specified.
	///
	/// \param[in] category The category of the message to construct.
	///
	/// \code{.cpp}
	/// Log::debug[L"Hello"] << L"There!" // => Logs There!, with category Hello
	/// \endcode
	template<typename TCategory>
	LogMessage operator[](const TCategory& category) {
		LogMessage result(*this, boost::lexical_cast<std::wstring>(category));

		return result;
	}

	/// Returns a new \ref LogMessage that has no category.
	///
	/// \param[in] message The message to construct. This can be implicitly
	///                    convertible to a string.
	template<typename TMessage>
	LogMessage operator<<(TMessage&& message) {
		LogMessage result(*this);
		result << std::forward<TMessage>(message);

		return result;
	}

	/// Checks if the current logger is active, i.e. that the active log level
	/// is equal to or lower than the current logger's severity. If the current
	/// logger is not active then all messages streamed to the logger are
	/// silently discarded.
	///
	/// \return True if the current logger is active.
	bool isActive() const;

	/// Writes the given message and category to the log. In contrast with
	/// operator<<, this is not lazy.
	///
	/// \param[in] message The message to write.
	/// \param[in] category The category to write.
	void write(const std::wstring& message,
		const std::wstring& category = std::wstring());

private:
	/// Constructs a new logger with the given severity.
	///
	/// \param[in] severity The severity of the current logger.
	explicit Logger(LogSeverity severity);
	Logger(const Logger&) = delete;
	Logger& operator=(const Logger&) = delete;

private:
	/// The severity of the messages generated by the current logger.
	LogSeverity severity;
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_LOG_LOGGER_H_

	// End of segment: .\You-Utils\log\logger.h





	/**
	 * origin: .\You-Utils\log\log_message.cpp
	 */

#include "stdafx.h"
#include "logger.h"
#include "log_message.h"

namespace You {
namespace Utils {

LogMessage::LogMessage(Logger& log, std::wstring category)
: logger(log), category(std::move(category)) {
}

LogMessage::LogMessage(LogMessage&& rhs)
: logger(rhs.logger),
category(std::move(rhs.category)),
components(std::move(rhs.components)) {
}

LogMessage::~LogMessage() {
	if (!components.empty() && logger.isActive()) {
		logger.write(evaluate(), category);
	}
}

std::wstring LogMessage::evaluate() const {
	std::wstring result;
	std::for_each(begin(components), end(components),
		[&result](const std::function<std::wstring()>& pickle) {
			result += pickle();
		});

	return result;
}

}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils\log\log_message.cpp





	/**
	 * origin: .\You-Utils\log\log_message.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_LOG_MESSAGE_H_
#define YOU_UTILS_LOG_LOG_MESSAGE_H_

#include <string>
#include <vector>
#include <functional>
#include <type_traits>

#include "../string_utils.h"

namespace You {
namespace Utils {

/// This Logger class deals with logging one message. It is the actual class
/// that constructs log messages.
class LogMessage {
	friend class Logger;

	/// Template metaprogram to check if T is a functor. This is named like this
	/// for mixing with Boost and the standard library.
	///
	/// Modified from http://stackoverflow.com/questions/15393938
	///
	/// \tparam TWithCVOrRef The raw type to check. This can have const/volatile
	///                      qualifiers (hence CV) or a reference (Ref).
	template<typename TWithCVOrRef>
	struct is_callable {
	private:
		template<typename T>
		struct check_callable {
		private:
			typedef char(&yes)[1];
			typedef char(&no)[2];

			struct Fallback { void operator()(); };
			#pragma warning(push)
			#pragma warning(disable: 4510 4610)
			struct Derived : T, Fallback {};
			#pragma warning(pop)

			template<typename U, U> struct Check;

			template<typename>
			static yes test(...);

			template<typename C>
			static no test(Check<void (Fallback::*)(), &C::operator()>*);

		public:
			static const bool value = sizeof(test<Derived>(0)) == sizeof(yes);
		};

		template<bool pointer>
		struct check_callable_if_not_pointer {
			static const bool value = check_callable<T>::value;
		};

		template<>
		struct check_callable_if_not_pointer<true> {
			static const bool value = false;
		};

		template<bool array>
		struct check_callable_if_not_array {
			static const bool value = check_callable_if_not_pointer<
				std::is_pointer<T>::value>::value;
		};

		template<>
		struct check_callable_if_not_array<true> {
			static const bool value = false;
		};

		template<bool fundamental>
		struct check_callable_if_not_fundamental {
			static const bool value =
				check_callable_if_not_array<std::is_array<T>::value>::
					value;
		};

		template<>
		struct check_callable_if_not_fundamental<true> {
			static const bool value = false;
		};

		template<bool function>
		struct check_callable_if_not_function {
			static const bool value =
				check_callable_if_not_fundamental<
					std::is_fundamental<T>::value>::value;
		};

		template<>
		struct check_callable_if_not_function<true> {
			static const bool value = true;
		};

		typename typedef std::remove_cv<TWithCVOrRef>::type TWithRef;
		typename typedef std::remove_reference<TWithRef>::type T;

	public:
		static const bool value =
			check_callable_if_not_function<
				std::is_function<T>::value>::value;
	};

	template<bool callable>
	struct writeTag {};
	typedef writeTag<true> callable;
	typedef writeTag<false> value;

public:
	/// Move constructor.
	LogMessage(LogMessage&& rhs);

	/// Destructor. Commits the message to the owning logger.
	~LogMessage();

	/// Writes the given message.
	///
	/// \param[in] thing The thing to write. This must be implicitly convertible
	///                  to a std::wstring using lexical_cast.
	template<typename TObject>
	LogMessage& operator<<(TObject&& object) {
		write(std::forward<TObject>(object),
			writeTag<is_callable<TObject>::value>());
		return *this;
	}

private:
	/// Constructs a new log message buffer, with the given category.
	///
	/// \param[in] log The logger this message will write to.
	/// \param[in] category The category of the message we are creating.
	explicit LogMessage(Logger& log, std::wstring category = std::wstring());
	LogMessage(const LogMessage&) = delete;
	LogMessage& operator=(const LogMessage&) = delete;

	/// Forces evaluation of the arguments.
	///
	/// \return The complete message.
	std::wstring evaluate() const;

	/// Writes the given message.
	///
	/// \param[in] pickle The function to apply. This must be a nullary function
	///                   returning a value convertible to std::wstring using
	///                   lexical_cast.
	template<typename TLazy>
	void write(const TLazy& pickle, callable) {
		components.emplace_back([pickle]() {
			return boost::lexical_cast<std::wstring>(pickle());
		});
	}

	/// Writes the given message.
	///
	/// \param[in] thing The thing to write. This must be implicitly convertible
	///                  to a std::wstring using lexical_cast.
	template<typename TObject>
	void write(const TObject& thing, value) {
		components.emplace_back([&thing]() {
			return boost::lexical_cast<std::wstring>(thing);
		});
	}

	/// Writes the given message.
	///
	/// \param[in] string The message to append. The message is not copied and
	///                   must have a lifetime longer than this.
	void write(const wchar_t* const string, value) {
		components.emplace_back([string] { return std::wstring(string); });
	}

	/// Writes the given message.
	///
	/// \param[in] string The message to append. The message is not copied and
	///                   must have a lifetime longer than this.
	void write(const char* const string, value) {
		components.emplace_back([string] {
			return toWString(string, strlen(string));
		});
	}

	/// Writes the given message.
	///
	/// \param[in] thing The message to append. The message is not copied and
	///                  must have a lifetime longer than this.
	void write(const std::wstring& string, value) {
		components.emplace_back([&string] { return string; });
	}

	/// Writes the given message.
	///
	/// \param[in] thing The message to append. The message is not copied and
	///                  must have a lifetime longer than this.
	void write(const std::string& string, value) {
		components.emplace_back([&string] {
			return toWString(string.c_str(), string.length());
		});
	}

private:
	/// The logger to write to.
	class Logger& logger;

	/// The category of the message.
	std::wstring category;

	/// The unevaluated components of the message.
	std::vector<std::function<std::wstring()>> components;
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_LOG_LOG_MESSAGE_H_

	// End of segment: .\You-Utils\log\log_message.h





	/**
	 * origin: .\You-Utils\log\log_severity.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_LOG_SEVERITY_H_
#define YOU_UTILS_LOG_LOG_SEVERITY_H_

namespace You {
namespace Utils {

/// The severity of log messages.
enum class LogSeverity {
	/// The message is of DEBUG severity.
	DEBUG = 0,

	/// The message is of INFO severity.
	INFO,

	/// The message is of WARNING severity.
	WARNING,

	/// The message is of ERROR severity.
	ERROR,

	/// The message is of CRITICAL severity.
	CRITICAL
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_LOG_LOG_SEVERITY_H_

	// End of segment: .\You-Utils\log\log_severity.h





	/**
	 * origin: .\You-Utils\log\log_sink.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_LOG_SINK_H_
#define YOU_UTILS_LOG_LOG_SINK_H_

#include "log_severity.h"

namespace You {
namespace Utils {

/// This represents the functions an abstract Log Sink must implement. This is
/// an implementation of the Observer pattern.
class LogSink {
public:
	virtual ~LogSink() = default;

	/// The method which will be called when a new log message is received.
	///
	/// \param[in] severity The severity of the message.
	/// \param[in] category The category of the message. This can be an empty
	///                     string for the default category.
	/// \param[in] message The message which was logged.
	virtual void onLog(LogSeverity severity,
		const std::wstring& category,
		const std::wstring& message) = 0;
};

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_LOG_LOG_SINK_H_

	// End of segment: .\You-Utils\log\log_sink.h





	/**
	 * origin: .\You-Utils\log.h
	 */

#pragma once
#ifndef YOU_UTILS_LOG_H_
#define YOU_UTILS_LOG_H_

#include "log/log.h"

#endif  // YOU_UTILS_LOG_H_

	// End of segment: .\You-Utils\log.h





	/**
	 * origin: .\You-Utils\option.h
	 */

#pragma once
#ifndef YOU_UTILS_OPTION_H_
#define YOU_UTILS_OPTION_H_

#include <boost/optional.hpp>

namespace You {
namespace Utils {

/// Implements an option type. This means that either the null value or an
/// actual value is contained within.
///
/// To test whether there is an actual value, cast this to a boolean.
template<typename T>
class Option : public boost::optional<T> {
public:
	/// Default constructor. This initialises a None value.
	inline Option() {
	}

	/// Copy construct from boost::none
	inline Option(const boost::none_t& value)  // NOLINT(runtime/explicit)
		: boost::optional<T>(value) {
	}

	/// Move constructor. This initialises a value from an existing value.
	inline Option(T&& value)  // NOLINT(runtime/explicit)
	: boost::optional<T>(std::move(value)) {
	}

	/// Copy constructor. This copies the value from an existing value.
	inline Option(const T& value)  // NOLINT(runtime/explicit)
	: boost::optional<T>(value) {
	}

	/// Move constructor.
	inline Option(const boost::optional<T>&& value)  // NOLINT(runtime/explicit)
 	: boost::optional<T>(value) {
	}

	/// By default boost::optional doesn't support the use of an implicit
	/// conversion to bool. We want this, so define our override.
	inline operator bool() const throw() {
		return boost::optional<T>::operator bool();
	}
};

template<typename T, typename... ParamTypes>
inline Option<T> make_option(ParamTypes&&... arguments) {
	return T(std::forward<ParamTypes>(arguments)...);
}

}  // namespace Utils
}  // namespace You

#endif  // YOU_UTILS_OPTION_H_

	// End of segment: .\You-Utils\option.h





	/**
	 * origin: .\You-Utils\string_utils.cpp
	 */

#include "stdafx.h"

namespace You {
namespace Utils {

std::wstring toWString(const char* string, size_t count) {
	std::wstring result;
	result.resize(count + 1);

	size_t resultCount = result.size();
	mbstowcs_s(&resultCount, &result.front(), resultCount, string, _TRUNCATE);

	result.erase(result.begin() + resultCount - 1, result.end());
	return result;
}

}  // namespace Utils
}  // namespace You

std::wostream& operator<<(std::wostream& stream, const std::string& string) {
	return stream << You::Utils::toWString(string.c_str(), string.length());
}

	// End of segment: .\You-Utils\string_utils.cpp





	/**
	 * origin: .\You-Utils\string_utils.h
	 */

#pragma once
#ifndef YOU_UTILS_STRING_UTILS_H_
#define YOU_UTILS_STRING_UTILS_H_

#include <iosfwd>
#include <string>

namespace You {
namespace Utils {

/// Helper to convert char strings to wchar_t strings.
///
/// \param[in] string The string to convert.
/// \param[in] count The number of characters to convert.
std::wstring toWString(const char* string, size_t count);

}  // namespace Utils
}  // namespace You

/// Overload to convert narrow to wide strings.
std::wostream& operator<<(std::wostream& stream, const std::string& string);

#endif  // YOU_UTILS_STRING_UTILS_H_

	// End of segment: .\You-Utils\string_utils.h





	/**
	 * origin: .\You-Utils-Tests\algorithms_tests.cpp
	 */

#include "stdafx.h"
#include "string_utils.h"
#include "algorithms.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace You {
namespace Utils {
namespace UnitTests {

TEST_CLASS(StringSimilarityTests) {
	/// Tests the class for both narrow and wide strings.
	template<typename T>
	void testContainsImpl(const T& lhs, const T& rhs, bool expect) {
		Assert::AreEqual(expect, similar_to<T>()(lhs, rhs));
	}

	/// Tests the class from narrow string input.
	void testContains(const char* lhs, const char* rhs, bool expect) {
		std::wstring lhsWString(boost::lexical_cast<std::wstring>(lhs));
		std::wstring rhsWString(boost::lexical_cast<std::wstring>(rhs));
		std::string lhsString(boost::lexical_cast<std::string>(lhs));
		std::string rhsString(boost::lexical_cast<std::string>(rhs));

		testContainsImpl(lhsWString, rhsWString, expect);
		testContainsImpl(lhsString, rhsString, expect);
	}

	TEST_METHOD(emptyStringDoesNotContain) {
		testContains("", "", false);
	}

	TEST_METHOD(emptySearchDoesNotMatch) {
		testContains("abc", "", false);
	}

	TEST_METHOD(singleWordContains) {
		testContains("ab", "a", true);
		testContains("ab", "b", true);
	}

	TEST_METHOD(singleWordSupersetDoesNotContain) {
		testContains("a", "ab", false);
	}

	TEST_METHOD(multiWordContains) {
		testContains("ab cd", "cd", true);
	}

	TEST_METHOD(searchMustMatchAll) {
		testContains("abc", "ab bc", true);
		testContains("abc", "ab cd", false);
	}

	TEST_METHOD(caseInsensitiveCompare) {
		testContains("abc", "AB BC", true);
	}
};

}  // namespace UnitTests
}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils-Tests\algorithms_tests.cpp





	/**
	 * origin: .\You-Utils-Tests\log_tests.cpp
	 */

#include "stdafx.h"
#include <boost/tuple/tuple.hpp>
#include "log.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace Microsoft {
namespace VisualStudio {
namespace CppUnitTestFramework {

std::wstring ToString(You::Utils::LogSeverity severity) {
	return ToString(static_cast<int>(severity));
}

}  // namespace CppUnitTestFramework
}  // namespace VisualStudio
}  // namespace Microsoft

namespace You {
namespace Utils {
namespace UnitTests {

class LogTesterSink : public LogSink {
public:
	LogTesterSink(LogSeverity expectedSeverity,
		const std::wstring& expectedCategory = std::wstring(),
		const std::wstring& expectedMessage = std::wstring())
	: callCount(0),
	expectedSeverity(expectedSeverity),
	expectedCategory(expectedCategory),
	expectedMessage(expectedMessage) {
	}

	void onLog(LogSeverity severity,
		const std::wstring& category,
		const std::wstring& message) override {
		Assert::AreEqual(expectedSeverity, severity);
		Assert::AreEqual(expectedCategory, category);
		Assert::AreEqual(expectedMessage, message);
		++callCount;
	}

	inline size_t getCallCount() const {
		return callCount;
	}

private:
	size_t callCount;
	LogSeverity expectedSeverity;
	std::wstring expectedCategory;
	std::wstring expectedMessage;
};

TEST_CLASS(LogTests) {
	TEST_METHOD_INITIALIZE(setLogSeverity) {
		Log::setLogLevel(LogSeverity::DEBUG);
		Log::restoreSink();
	}

	TEST_METHOD(defaultLogSink) {
		Log::debug[L"category"] << L"test";
	}

	TEST_METHOD(basicLogging) {
		std::shared_ptr<LogTesterSink> tester(
			std::make_shared<LogTesterSink>(LogSeverity::DEBUG, L"", L"lol2"));
		Log::setSink(tester);
		Log::debug << std::wstring(L"lol2");
		Assert::AreEqual(1U, tester->getCallCount());

		Log::debug << L"lo" << L"l" << 2;
		Assert::AreEqual(2U, tester->getCallCount());
	}

	TEST_METHOD(lazyLogging) {
		Log::setLogLevel(LogSeverity::CRITICAL);
		std::shared_ptr<LogTesterSink> tester(
			std::make_shared<LogTesterSink>(LogSeverity::DEBUG));
		Log::setSink(tester);

		bool called = false;
		auto callerCheck = [&called]() {
			called = true; return L"";
		};
		Log::debug << callerCheck;
		Assert::IsFalse(called);
		Assert::AreEqual(0U, tester->getCallCount());

		Log::setLogLevel(LogSeverity::DEBUG);
		Log::debug << callerCheck;
		Assert::IsTrue(called);
		Assert::AreEqual(1U, tester->getCallCount());
	}

	TEST_METHOD(asciiLogging) {
		std::shared_ptr<LogTesterSink> tester(
			std::make_shared<LogTesterSink>(LogSeverity::DEBUG, L"", L"lol2"));
		Log::setSink(tester);
		Log::debug << "lol2";
		Assert::AreEqual(1U, tester->getCallCount());

		Log::debug << std::string("lol2");
		Assert::AreEqual(2U, tester->getCallCount());
	}

	TEST_METHOD(correctLogLevels) {
		Log::setSink(std::make_shared<LogTesterSink>(LogSeverity::DEBUG));
		Log::debug << L"";

		Log::setSink(std::make_shared<LogTesterSink>(LogSeverity::INFO));
		Log::info << L"";

		Log::setSink(std::make_shared<LogTesterSink>(LogSeverity::WARNING));
		Log::warning << L"";

		Log::setSink(std::make_shared<LogTesterSink>(LogSeverity::ERROR));
		Log::error << L"";

		Log::setSink(std::make_shared<LogTesterSink>(LogSeverity::CRITICAL));
		Log::critical << L"";
	}
};

}  // namespace UnitTests
}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils-Tests\log_tests.cpp





	/**
	 * origin: .\You-Utils-Tests\option_tests.cpp
	 */

#include "stdafx.h"
#include "option.h"

using Assert = Microsoft::VisualStudio::CppUnitTestFramework::Assert;

namespace Microsoft {
namespace VisualStudio {
namespace CppUnitTestFramework {

template<typename T>
std::wstring ToString(const You::Utils::Option<T>& value) {
	if (value) {
		return ToString(value.get());
	} else {
		return L"(none)";
	}
}

}  // namespace CppUnitTestFramework
}  // namespace VisualStudio
}  // namespace Microsoft

namespace You {
namespace Utils {
namespace UnitTests {

TEST_CLASS(OptionTests) {
	TEST_METHOD(defaultConstructorConstructsFalseyObject) {
		Assert::IsFalse(Option<int>());
		Assert::IsFalse(Option<int>(boost::none));
	}

	TEST_METHOD(constructorWithFalseyValueIsTrue) {
		Assert::IsTrue(Option<int>(0));
	}

	TEST_METHOD(getsValidValue) {
		Assert::AreEqual(42, Option<int>(42).get());

		const Option<int> test(43);
		Assert::AreEqual(43, test.get());
	}

	TEST_METHOD(comparesEquality) {
		const Option<int> blank;
		const Option<int> something(42);

		Assert::AreEqual(blank, blank);
		Assert::AreEqual(something, something);
		Assert::AreNotEqual(blank, something);
		Assert::AreNotEqual(something, blank);
	}
};

}  // namespace UnitTests
}  // namespace Utils
}  // namespace You

	// End of segment: .\You-Utils-Tests\option_tests.cpp





	/**
	 * origin: .\You-Utils-Tests\test_helpers.h
	 */

#pragma once
#ifndef YOU_UTILS_TESTS_TEST_HELPERS_H_
#define YOU_UTILS_TESTS_TEST_HELPERS_H_

#include <string>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/variant/variant.hpp>

namespace You {
namespace NLP {
namespace UnitTests {

/// Applies ToString to the element in the container.
struct ToStringVisitor : public boost::static_visitor<std::wstring> {
	/// Applies ToString to the given element in the variant.
	template<typename T>
	std::wstring operator()(const T& value) {
		return ToString(value);
	}
};

}  // namespace UnitTests
}  // namespace NLP
}  // namespace You

namespace boost {

template<typename... T1>
std::wstring ToString(const variant<T1...>& t) {
	You::NLP::UnitTests::ToStringVisitor visitor;
	return apply_visitor(visitor, t);
}

inline std::wstring ToString(const boost::gregorian::date& date) {
	return boost::lexical_cast<std::wstring>(date);
}

inline std::wstring ToString(const boost::posix_time::ptime& time) {
	return boost::lexical_cast<std::wstring>(time);
}

}  // namespace boost

namespace Microsoft {
namespace VisualStudio {
namespace CppUnitTestFramework {

/// Missing overloads.
/// @{
// NOLINTNEXTLINE(runtime/int)
template<> static std::wstring ToString<long long>(const long long& t) {
	RETURN_WIDE_STRING(t);
}
// NOLINTNEXTLINE(runtime/int)
template<> static std::wstring ToString<long long>(const long long* t) {
	RETURN_WIDE_STRING(t);
}
// NOLINTNEXTLINE(runtime/int)
template<> static std::wstring ToString<long long>(long long* t) {
	RETURN_WIDE_STRING(t);
}

template<> static std::wstring ToString<unsigned short>(  // NOLINT(runtime/int)
	const unsigned short& t) {  // NOLINT(runtime/int)
	RETURN_WIDE_STRING(t);
}
template<> static std::wstring ToString<unsigned short>(  // NOLINT(runtime/int)
	const unsigned short* t) {  // NOLINT(runtime/int)
	RETURN_WIDE_STRING(t);
}
template<> static std::wstring ToString<unsigned short>(  // NOLINT(runtime/int)
	unsigned short* t) {  // NOLINT(runtime/int)
	RETURN_WIDE_STRING(t);
}
/// }

}  // namespace CppUnitTestFramework
}  // namespace VisualStudio
}  // namespace Microsoft

#endif  // YOU_UTILS_TESTS_TEST_HELPERS_H_

	// End of segment: .\You-Utils-Tests\test_helpers.h





